<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>magnavpy.dcm_util &#8212; MagNavPy 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=73454398" />
    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">MagNavPy</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=manasp21&repo=magnav.py&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Flight Path &amp; INS Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maps.html">Magnetic Anomaly Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../comp.html">Aeromagnetic Compensation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nncomp.html">Neural Network-Based Model Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nav.html">Navigation Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../status.html">Current Status and Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_functions.html">API: Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_structs.html">API: Structs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for magnavpy.dcm_util</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<div class="viewcode-block" id="skew">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.magnav.skew">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">skew</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a skew-symmetric matrix from a 3-element vector.</span>

<span class="sd">    :param v: 3-element numpy array</span>
<span class="sd">    :type v: np.ndarray</span>

<span class="sd">    :return: 3x3 skew-symmetric matrix</span>
<span class="sd">    :rtype: np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be a 3-element numpy array.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">])</span></div>


<div class="viewcode-block" id="dcm2euler">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.magnav.dcm2euler">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dcm2euler</span><span class="p">(</span><span class="n">Cnb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;zyx&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Direction Cosine Matrix (DCM) to Euler angles.</span>

<span class="sd">    :param Cnb: 3x3xN (or 3x3) Direction Cosine Matrix.</span>
<span class="sd">                If 3x3xN, returns N Euler angle sets.</span>
<span class="sd">    :type Cnb: np.ndarray</span>
<span class="sd">    :param order: Euler angle rotation order and interpretation.</span>
<span class="sd">                  Default is &#39;zyx&#39;.</span>
<span class="sd">                  Supported orders:</span>
<span class="sd">                  - &#39;zyx&#39;: Assumes Cnb = Rz(yaw)Ry(pitch)Rx(roll). Returns (yaw, pitch, roll)</span>
<span class="sd">                  - &#39;xyz&#39;: Assumes Cnb is a DCM from which roll, pitch, yaw are to be extracted</span>
<span class="sd">                           using formulas typically applied to Cbn = (Rz(yaw)Ry(pitch)Rx(roll))^T.</span>
<span class="sd">                           Effectively, if Cnb is Cbn_julia, this returns (roll, pitch, yaw)</span>
<span class="sd">                  - &#39;body2nav&#39;: Returns (roll, pitch, yaw)</span>
<span class="sd">    :type order: str, optional</span>

<span class="sd">    :return: Euler angles in radians</span>
<span class="sd">             If Cnb is 3x3, returns a 1D array of 3 elements: [angle1, angle2, angle3]</span>
<span class="sd">             If Cnb is 3x3xN, returns a 2D array of shape (N, 3): [[a1,a2,a3], ...]</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    .. note::</span>
<span class="sd">        The interpretation of angles depends on &#39;order&#39;:</span>
<span class="sd">        - For &#39;zyx&#39;: (yaw, pitch, roll)</span>
<span class="sd">        - For &#39;xyz&#39;: (roll, pitch, yaw)</span>
<span class="sd">        - For &#39;body2nav&#39;: (roll, pitch, yaw)</span>

<span class="sd">    **Julia MagNav.jl Mapping**:</span>

<span class="sd">    To match Julia ``dcm2euler(Cnb, order=:body2nav)`` which returns ``(roll, pitch, yaw)``:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        yaw_py, pitch_py, roll_py = dcm2euler(Cnb, order=&#39;zyx&#39;)</span>
<span class="sd">        # Result: (roll_py, pitch_py, yaw_py)</span>

<span class="sd">    To match Julia ``dcm2euler(Cbn, order=:nav2body)`` which returns ``(roll, pitch, yaw)``</span>
<span class="sd">    (where Cbn is the DCM from navigation to body frame, i.e., Cnb_julia.T):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        roll_py, pitch_py, yaw_py = dcm2euler(Cbn, order=&#39;xyz&#39;)</span>
<span class="sd">        # Result: (roll_py, pitch_py, yaw_py)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">Cnb_proc</span> <span class="o">=</span> <span class="n">Cnb</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># Make it 3x3x1 for consistent processing</span>
    <span class="k">elif</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Cnb_proc</span> <span class="o">=</span> <span class="n">Cnb</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input DCM must be 3x3 or 3x3xN&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">Cnb_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">angle1_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">angle2_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">angle3_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">Cnb_proc</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;zyx&#39;</span><span class="p">:</span> <span class="c1"># Yaw, Pitch, Roll from Cnb = Rz(yaw)Ry(pitch)Rx(roll)</span>
            <span class="n">pitch_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pitch_val</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">pitch_val</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">pitch_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span> <span class="c1"># Near pi/2 or -pi/2 (Gimbal lock)</span>
                <span class="n">roll</span> <span class="o">=</span> <span class="mf">0.0</span> 
                <span class="n">yaw</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">roll</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">yaw</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">angle1_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">yaw</span>
            <span class="n">angle2_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pitch</span>
            <span class="n">angle3_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">roll</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="c1"># Extracts (roll, pitch, yaw) assuming C is effectively Cbn_julia</span>
                             <span class="c1"># Cbn_julia[1,3] (0-indexed C[0,2]) = -sin(pitch)</span>
                             <span class="c1"># Cbn_julia[2,3] (0-indexed C[1,2]) = sin(roll)cos(pitch)</span>
                             <span class="c1"># Cbn_julia[3,3] (0-indexed C[2,2]) = cos(roll)cos(pitch)</span>
                             <span class="c1"># Cbn_julia[1,2] (0-indexed C[0,1]) = cos(pitch)sin(yaw)</span>
                             <span class="c1"># Cbn_julia[1,1] (0-indexed C[0,0]) = cos(pitch)cos(yaw)</span>
            <span class="n">pitch_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">pitch_val</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">pitch_val</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">pitch_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span> <span class="c1"># Gimbal lock</span>
                <span class="c1"># For Cbn, if pitch = pi/2 (sp=1, cp=0):</span>
                <span class="c1"># Cbn = [[0,0,-1],[-cr*sy+sr*cy, cr*cy+sr*sy, 0],[sr*sy+cr*cy, -sr*cy+cr*sy,0]]</span>
                <span class="c1"># yaw and roll are not uniquely defined. Set yaw = 0.</span>
                <span class="c1"># roll = atan2(C[1,0], C[2,0]) (if C[1,0]=sin(roll-yaw), C[2,0]=cos(roll-yaw))</span>
                <span class="c1"># roll = atan2(C[1,0], C[1,1]) is not directly applicable here.</span>
                <span class="c1"># From Julia dcm2euler for nav2body, if pitch is +/-pi/2,</span>
                <span class="c1"># roll = atan2(c23,c33) and yaw = atan2(c12,c11) would have cos(pitch)=0 in denominator.</span>
                <span class="c1"># A common convention: yaw = 0, roll = atan2(C[1,0], C[2,0]) (if C is from XYZ)</span>
                <span class="c1"># Or, roll = 0, yaw = atan2(C[1,0],C[0,0]) (if C is from ZYX)</span>
                <span class="c1"># Let&#39;s follow a convention for Cbn: yaw=0, roll = atan2(C[1,0], C[1,1])</span>
                <span class="c1"># C[1,0] = -cr*sy+sr*sp*cy ; C[1,1] = cr*cy+sr*sp*sy</span>
                <span class="c1"># If pitch = pi/2 (sp=1): C[1,0] = -cr*sy+sr*cy; C[1,1] = cr*cy+sr*sy</span>
                <span class="c1"># roll = atan2(-cr*sy+sr*cy, cr*cy+sr*sy) = atan2(sin(roll-yaw_orig), cos(roll-yaw_orig))</span>
                <span class="c1"># This is roll - yaw_original. If yaw_original is not necessarily 0.</span>
                <span class="c1"># For simplicity and to match typical gimbal lock handling where one angle is arbitrary:</span>
                <span class="n">yaw_extracted</span> <span class="o">=</span> <span class="mf">0.0</span> 
                <span class="n">roll_extracted</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># This is roll_orig - yaw_orig if C=Cnb.T</span>
                                                          <span class="c1"># If C=Cbn, this is atan2(-cr*sy+sr*cy, cr*cy+sr*sy)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">roll_extracted</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> 
                <span class="n">yaw_extracted</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> 

            <span class="n">angle1_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">roll_extracted</span> 
            <span class="n">angle2_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pitch</span>      
            <span class="n">angle3_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">yaw_extracted</span> 
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;body2nav&#39;</span><span class="p">:</span> <span class="c1"># Roll, Pitch, Yaw from Cnb = Rz(yaw)Ry(pitch)Rx(roll)</span>
            <span class="c1"># Calculations are the same as &#39;zyx&#39; for yaw_calc, pitch_calc, roll_calc</span>
            <span class="c1"># but the output order is (roll, pitch, yaw)</span>
            <span class="n">pitch_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pitch_val</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">current_pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">elif</span> <span class="n">pitch_val</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">:</span>
                <span class="n">current_pitch</span> <span class="o">=</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_pitch</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">pitch_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">current_pitch</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span> <span class="c1"># Gimbal lock</span>
                <span class="c1"># Following &#39;zyx&#39; gimbal lock convention:</span>
                <span class="n">current_roll</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">current_yaw</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_roll</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">current_yaw</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

            <span class="n">angle1_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_roll</span>  <span class="c1"># roll</span>
            <span class="n">angle2_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_pitch</span> <span class="c1"># pitch</span>
            <span class="n">angle3_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_yaw</span>   <span class="c1"># yaw</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported Euler angle order for dcm2euler: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># If input was 3x3, return a 1D array</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle1_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle2_out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle3_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="c1"># If input was 3x3xN, return an Nx3 array</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">angle1_out</span><span class="p">,</span> <span class="n">angle2_out</span><span class="p">,</span> <span class="n">angle3_out</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="euler2dcm">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.magnav.euler2dcm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">euler2dcm</span><span class="p">(</span><span class="n">angle1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
              <span class="n">angle2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
              <span class="n">angle3</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
              <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;zyx&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Euler angles to Direction Cosine Matrix (DCM).</span>

<span class="sd">    :param angle1: First Euler angle in radians (interpretation depends on &#39;order&#39;)</span>
<span class="sd">    :type angle1: Union[float, np.ndarray]</span>
<span class="sd">    :param angle2: Second Euler angle in radians (interpretation depends on &#39;order&#39;)</span>
<span class="sd">    :type angle2: Union[float, np.ndarray]</span>
<span class="sd">    :param angle3: Third Euler angle in radians (interpretation depends on &#39;order&#39;)</span>
<span class="sd">    :type angle3: Union[float, np.ndarray]</span>
<span class="sd">    :param order: Euler angle rotation order. Default is &#39;zyx&#39;.</span>
<span class="sd">                  Supported orders:</span>
<span class="sd">                  - &#39;zyx&#39;: angle1=yaw, angle2=pitch, angle3=roll. DCM = Rz(yaw)Ry(pitch)Rx(roll)</span>
<span class="sd">                  - &#39;xyz&#39;: angle1=roll, angle2=pitch, angle3=yaw. DCM = Rx(roll)Ry(pitch)Rz(yaw)</span>
<span class="sd">                  - &#39;body2nav&#39;: angle1=roll, angle2=pitch, angle3=yaw. Produces Cnb (equivalent to Rz(yaw)Ry(pitch)Rx(roll))</span>
<span class="sd">    :type order: str, optional</span>

<span class="sd">    :return: Direction Cosine Matrix</span>
<span class="sd">             3x3xN (if inputs are arrays) or 3x3 (if inputs are scalars)</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    **Julia MagNav.jl Mapping**:</span>

<span class="sd">    To match Julia ``euler2dcm(roll, pitch, yaw, order=:body2nav)`` which produces Cnb:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        Cnb_py = euler2dcm(yaw, pitch, roll, order=&#39;zyx&#39;)</span>

<span class="sd">    To match Julia ``euler2dcm(roll, pitch, yaw, order=:nav2body)`` which produces Cbn (Cnb_julia.T):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        Cnb_temp = euler2dcm(yaw, pitch, roll, order=&#39;zyx&#39;)</span>
<span class="sd">        if Cnb_temp.ndim == 2:</span>
<span class="sd">            Cbn_py = Cnb_temp.T</span>
<span class="sd">        else:  # 3x3xN</span>
<span class="sd">            Cbn_py = np.transpose(Cnb_temp, axes=(1,0,2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_scalar</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">angle1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">angle1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> \
                  <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">angle2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">angle2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> \
                  <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">angle3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">angle3</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_scalar</span><span class="p">:</span>
        <span class="c1"># Ensure inputs are float for math functions</span>
        <span class="n">a1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">angle1</span><span class="p">)])</span>
        <span class="n">a2_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">angle2</span><span class="p">)])</span>
        <span class="n">a3_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">angle3</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a1_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angle1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">a2_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angle2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">a3_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">angle3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a1_arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a2_arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">a3_arr</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input angle arrays must have the same length.&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1_arr</span><span class="p">)</span>
    <span class="n">C_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">a1_val</span><span class="p">,</span> <span class="n">a2_val</span><span class="p">,</span> <span class="n">a3_val</span> <span class="o">=</span> <span class="n">a1_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a2_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a3_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;zyx&#39;</span><span class="p">:</span> <span class="c1"># angle1=yaw (Z), angle2=pitch (Y&#39;), angle3=roll (X&#39;&#39;)</span>
            <span class="n">Rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span><span class="p">,</span>                <span class="mi">1</span><span class="p">]</span>
            <span class="p">])</span>
            <span class="n">Ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>               <span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span>               <span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">C_out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rz</span> <span class="o">@</span> <span class="n">Ry</span> <span class="o">@</span> <span class="n">Rx</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> <span class="c1"># angle1=roll (X), angle2=pitch (Y&#39;), angle3=yaw (Z&#39;&#39;)</span>
            <span class="n">Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span>               <span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">Ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>               <span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">Rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span><span class="p">,</span>                <span class="mi">1</span><span class="p">]</span>
            <span class="p">])</span>
            <span class="n">C_out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rx</span> <span class="o">@</span> <span class="n">Ry</span> <span class="o">@</span> <span class="n">Rz</span>
        <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;body2nav&#39;</span><span class="p">:</span> <span class="c1"># angle1=roll, angle2=pitch, angle3=yaw. Cnb = Rz(yaw)Ry(pitch)Rx(roll)</span>
            <span class="c1"># This means: yaw_val = a3_val, pitch_val = a2_val, roll_val = a1_val</span>
            <span class="c1"># Rz uses yaw_val (a3_val)</span>
            <span class="c1"># Ry uses pitch_val (a2_val)</span>
            <span class="c1"># Rx uses roll_val (a1_val)</span>
            <span class="n">Rz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span> <span class="c1"># yaw is angle3</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a3_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span><span class="p">,</span>                <span class="mi">1</span><span class="p">]</span>
            <span class="p">])</span>
            <span class="n">Ry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span>  <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)],</span> <span class="c1"># pitch is angle2</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span>                 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>               <span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a2_val</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a2_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">Rx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                 <span class="mi">0</span>               <span class="p">],</span> <span class="c1"># roll is angle1</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">)],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a1_val</span><span class="p">),</span>  <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a1_val</span><span class="p">)]</span>
            <span class="p">])</span>
            <span class="n">C_out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rz</span> <span class="o">@</span> <span class="n">Ry</span> <span class="o">@</span> <span class="n">Rx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported Euler angle order for euler2dcm: </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_scalar</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">C_out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">C_out</span></div>


<div class="viewcode-block" id="correct_Cnb">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.magnav.correct_Cnb">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">correct_Cnb</span><span class="p">(</span><span class="n">Cnb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tilt_err</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrects a body-to-navigation DCM (Cnb) with tilt angle errors.</span>

<span class="sd">    The resulting DCM is the &quot;estimated&quot; or &quot;in error&quot; Cnb:</span>
<span class="sd">        Cnb_estimate = R_error * Cnb_true</span>
<span class="sd">    where R_error = expm(skew(-tilt_err)) is the rotation matrix from the tilt_err vector.</span>

<span class="sd">    This function ports the logic from MagNav.jl/src/dcm.jl correct_Cnb.</span>
<span class="sd">    The formula for B (R_error) used in Julia:</span>
<span class="sd">        B = I - (sin(m)/m)*S_psi - ((1-cos(m))/m^2)*(S_psi @ S_psi)</span>
<span class="sd">    where m = ||tilt_err|| and S_psi = skew(tilt_err).</span>
<span class="sd">    This B corresponds to expm(skew(-tilt_err)).</span>

<span class="sd">    :param Cnb: 3x3xN (or 3x3) true Direction Cosine Matrix (body to navigation)</span>
<span class="sd">    :type Cnb: np.ndarray</span>
<span class="sd">    :param tilt_err: 3xN (or 3x1 or 1D array of 3) tilt angle error vector [rad].</span>
<span class="sd">                     Each column is an [X, Y, Z] tilt error.</span>
<span class="sd">    :type tilt_err: np.ndarray</span>

<span class="sd">    :return: 3x3xN (or 3x3) &quot;in error&quot; Direction Cosine Matrix</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    .. note::</span>
<span class="sd">        The function includes debug print statements that should be removed in production.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Debugging for Error 2</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_ERROR_2: type(tilt_err): </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_ERROR_2: tilt_err.shape: </span><span class="si">{</span><span class="n">tilt_err</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_ERROR_2: len(tilt_err): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_ERROR_2: tilt_err: </span><span class="si">{</span><span class="n">tilt_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">Cnb_proc</span> <span class="o">=</span> <span class="n">Cnb</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">Cnb_proc</span> <span class="o">=</span> <span class="n">Cnb</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input Cnb DCM must be 3x3 or 3x3xN&quot;</span><span class="p">)</span>

    <span class="c1"># Process tilt_err to be 3xN, ensuring it&#39;s a numpy array of float for subsequent operations.</span>
    <span class="k">if</span> <span class="n">tilt_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tilt_err cannot be None.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">tilt_err_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Handles single number case if list was e.g. [0.1]</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_err sequence must represent a 3-element vector or 3xN array, got scalar-like </span><span class="si">{</span><span class="n">tilt_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1D tilt_err sequence must have 3 elements, got shape </span><span class="si">{</span><span class="n">tilt_err_np</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">tilt_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">tilt_err_proc</span> <span class="o">=</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tilt_err_np</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                 <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2D tilt_err sequence must have 3 rows (shape 3xN), got shape </span><span class="si">{</span><span class="n">tilt_err_np</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">tilt_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">tilt_err_proc</span> <span class="o">=</span> <span class="n">tilt_err_np</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_err sequence converted to array has unsupported ndim </span><span class="si">{</span><span class="n">tilt_err_np</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">tilt_err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">tilt_err_proc</span> <span class="o">=</span> <span class="n">tilt_err</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># Ensure float</span>
        <span class="k">if</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;1D tilt_err numpy array must have 3 elements, got shape </span><span class="si">{</span><span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">tilt_err_proc</span> <span class="o">=</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;2D tilt_err numpy array must be of shape 3xN, got </span><span class="si">{</span><span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_err numpy array must be 1D (3 elements) or 2D (shape 3xN), got ndim </span><span class="si">{</span><span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_err must be a list, tuple, or numpy array, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tilt_err</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


    <span class="n">num_Cnb</span> <span class="o">=</span> <span class="n">Cnb_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">num_tilt</span> <span class="o">=</span> <span class="n">tilt_err_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">num_Cnb</span> <span class="o">!=</span> <span class="n">num_tilt</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_Cnb</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">num_tilt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Apply single Cnb to multiple errors</span>
             <span class="n">Cnb_proc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Cnb_proc</span><span class="p">,</span> <span class="n">num_tilt</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">num_tilt</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">num_Cnb</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Apply single error to multiple Cnbs</span>
             <span class="n">tilt_err_proc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">tilt_err_proc</span><span class="p">,</span> <span class="n">num_Cnb</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of Cnb matrices (</span><span class="si">{</span><span class="n">num_Cnb</span><span class="si">}</span><span class="s2">) and tilt_err vectors (</span><span class="si">{</span><span class="n">num_tilt</span><span class="si">}</span><span class="s2">) must match, &quot;</span>
                <span class="s2">&quot;or one of them must be singular (N=1).&quot;</span>
            <span class="p">)</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">Cnb_proc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Cnb_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Cnb_proc</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">tilt_err_proc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
        
        <span class="n">S_psi</span> <span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span> <span class="c1"># Handles m == 0 case</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Formula from Julia: B = I - sin(m)/m*s - (1-cos(m))/m^2*s^2</span>
            <span class="c1"># This corresponds to expm(skew(-psi))</span>
            <span class="n">term_sin_m_div_m</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span>
            <span class="n">term_1_minus_cos_m_div_m_sq</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span>
            
            <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">term_sin_m_div_m</span> <span class="o">*</span> <span class="n">S_psi</span> <span class="o">-</span> \
                <span class="n">term_1_minus_cos_m_div_m_sq</span> <span class="o">*</span> <span class="p">(</span><span class="n">S_psi</span> <span class="o">@</span> <span class="n">S_psi</span><span class="p">)</span>
        
        <span class="n">Cnb_estimate</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">Cnb_proc</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">Cnb</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">tilt_err</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span> <span class="c1"># If original inputs were singular</span>
        <span class="k">return</span> <span class="n">Cnb_estimate</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Cnb_estimate</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2023, Original MagNav.jl Authors; 2024-2025, Manas Pandey.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>