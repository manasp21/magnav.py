<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>magnavpy.create_xyz &#8212; MagNavPy 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for magnavpy.create_xyz</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module is responsible for creating and initializing XYZ data objects,</span>
<span class="sd">translated from the Julia MagNav.jl/src/create_XYZ.jl.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">multivariate_normal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="c1"># Attempt to import from project modules</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.map_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_map_val</span> <span class="c1"># Added import</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.magnav</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">XYZ0</span><span class="p">,</span> <span class="n">Traj</span><span class="p">,</span> <span class="n">INS</span><span class="p">,</span> <span class="n">MagV</span><span class="p">,</span> <span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span>
                           <span class="n">BaseMap</span><span class="p">,</span> <span class="c1"># Assuming BaseMap is a common base for MapS, MapSd, etc.</span>
                           <span class="n">Path</span><span class="p">)</span> <span class="c1"># Path = Union[Traj, INS] or a base class</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.analysis_util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">add_extension</span><span class="p">,</span> <span class="n">g_earth</span><span class="p">,</span> <span class="n">get_map</span><span class="p">,</span> <span class="n">map_check</span><span class="p">,</span> <span class="n">dlat2dn</span><span class="p">,</span> <span class="n">dlon2de</span><span class="p">,</span> <span class="n">dn2dlat</span><span class="p">,</span>
        <span class="n">de2dlon</span><span class="p">,</span> <span class="n">fdm</span><span class="p">,</span> <span class="n">utm_zone_from_latlon</span><span class="p">,</span> <span class="n">transform_lla_to_utm</span><span class="p">,</span> <span class="c1"># Assumed geospatial helpers</span>
        <span class="n">create_dcm_from_vel</span><span class="p">,</span> <span class="n">dcm2euler</span><span class="p">,</span> <span class="n">euler2dcm</span><span class="p">,</span> <span class="c1"># Attitude helpers</span>
        <span class="n">create_ins_model_matrices</span><span class="p">,</span> <span class="n">get_phi_matrix</span><span class="p">,</span> <span class="n">correct_cnb_matrix</span><span class="p">,</span> <span class="c1"># INS helpers</span>
        <span class="n">upward_fft_map</span><span class="p">,</span> <span class="n">get_map_params</span><span class="p">,</span> <span class="n">fill_map_gaps</span><span class="p">,</span> <span class="n">trim_map</span><span class="p">,</span> <span class="c1"># get_map_value_at_coords removed</span>
        <span class="n">generate_fogm_noise</span><span class="p">,</span> <span class="n">create_tolles_lawson_A_matrix</span><span class="p">,</span> <span class="c1"># Noise &amp; TL helpers</span>
        <span class="n">get_igrf_magnetic_field</span><span class="p">,</span> <span class="c1"># IGRF helper</span>
        <span class="n">apply_band_pass_filter</span><span class="p">,</span> <span class="n">get_band_pass_filter_coeffs</span><span class="p">,</span> <span class="c1"># Filter helpers</span>
        <span class="n">tolles_lawson_coeffs_to_matrix</span><span class="p">,</span> <span class="n">get_tolles_lawson_aircraft_field_vector</span><span class="p">,</span> <span class="c1"># More TL helpers</span>
        <span class="n">get_trajectory_subset</span><span class="p">,</span> <span class="c1"># Helper for xyz.traj(ind) like behavior</span>
        <span class="n">approximate_gradient</span> <span class="c1"># Helper for map gradient</span>
    <span class="p">)</span>
    <span class="c1"># Define default map identifiers if they are constants in analysis_util</span>
    <span class="n">DEFAULT_SCALAR_MAP_ID</span> <span class="o">=</span> <span class="s2">&quot;namad&quot;</span> <span class="c1"># Placeholder</span>
    <span class="n">DEFAULT_VECTOR_MAP_ID</span> <span class="o">=</span> <span class="s2">&quot;emm720&quot;</span> <span class="c1"># Placeholder</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Fallback for standalone execution or if modules are structured differently</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Could not import from .magnav or .analysis_util. Placeholder types and functions will be used.&quot;</span><span class="p">)</span>
    <span class="c1"># Define dummy classes and functions if needed for linting/testing without full project</span>
<div class="viewcode-block" id="BaseMap">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.BaseMap">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">BaseMap</span><span class="p">:</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="MapS">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.MapS">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapS</span><span class="p">(</span><span class="n">BaseMap</span><span class="p">):</span> <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="nb">map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">alt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span></div>

<div class="viewcode-block" id="MapSd">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.MapSd">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapSd</span><span class="p">(</span><span class="n">MapS</span><span class="p">):</span> <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MapS3D">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.MapS3D">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapS3D</span><span class="p">(</span><span class="n">MapS</span><span class="p">):</span> <span class="n">zz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="n">alt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># alt might be 3D grid</span></div>

<div class="viewcode-block" id="MapV">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.MapV">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapV</span><span class="p">(</span><span class="n">BaseMap</span><span class="p">):</span><span class="k">pass</span></div>

<div class="viewcode-block" id="Traj">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.Traj">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Traj</span><span class="p">:</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">;</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">;</span> <span class="n">tt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">lat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">lon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">alt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">vn</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">ve</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">vd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">fn</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">fe</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">fd</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">Cnb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span></div>

<div class="viewcode-block" id="INS">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.INS">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">INS</span><span class="p">(</span><span class="n">Traj</span><span class="p">):</span> <span class="n">P</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="c1"># Covariance matrices</span></div>

<div class="viewcode-block" id="MagV">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.MagV">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MagV</span><span class="p">:</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span></div>

<div class="viewcode-block" id="XYZ0">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.XYZ0">[docs]</a>
    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">XYZ0</span><span class="p">:</span> <span class="n">info</span><span class="p">:</span> <span class="nb">str</span><span class="p">;</span> <span class="n">traj</span><span class="p">:</span> <span class="n">Traj</span><span class="p">;</span> <span class="n">ins</span><span class="p">:</span> <span class="n">INS</span><span class="p">;</span> <span class="n">flux_a</span><span class="p">:</span> <span class="n">MagV</span><span class="p">;</span> <span class="n">flights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">years</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">doys</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">diurnal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">igrf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">mag_1_c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">;</span> <span class="n">mag_1_uc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span></div>

    <span class="n">Path</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Traj</span><span class="p">,</span> <span class="n">INS</span><span class="p">]</span>
<div class="viewcode-block" id="add_extension">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.add_extension">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_extension</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span> <span class="k">return</span> <span class="n">s</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="k">else</span> <span class="n">s</span> <span class="o">+</span> <span class="n">ext</span></div>

    <span class="n">g_earth</span> <span class="o">=</span> <span class="mf">9.80665</span>
<div class="viewcode-block" id="get_map">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_map</span><span class="p">(</span><span class="n">map_id</span><span class="p">):</span> <span class="k">return</span> <span class="n">MapS</span><span class="p">(</span><span class="n">xx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">yy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="nb">map</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Dummy</span></div>

    <span class="n">DEFAULT_SCALAR_MAP_ID</span> <span class="o">=</span> <span class="s2">&quot;namad&quot;</span>
    <span class="n">DEFAULT_VECTOR_MAP_ID</span> <span class="o">=</span> <span class="s2">&quot;emm720&quot;</span>
    <span class="c1"># Add other dummy functions as needed based on usage below...</span>
<div class="viewcode-block" id="map_check">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.map_check">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_check</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">la</span><span class="p">,</span><span class="n">lo</span><span class="p">):</span> <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="dlat2dn">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.dlat2dn">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dlat2dn</span><span class="p">(</span><span class="n">dlat</span><span class="p">,</span><span class="n">lat</span><span class="p">):</span> <span class="k">return</span> <span class="n">dlat</span> <span class="o">*</span> <span class="mi">111000</span></div>

<div class="viewcode-block" id="dlon2de">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.dlon2de">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dlon2de</span><span class="p">(</span><span class="n">dlon</span><span class="p">,</span><span class="n">lat</span><span class="p">):</span> <span class="k">return</span> <span class="n">dlon</span> <span class="o">*</span> <span class="mi">111000</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span></div>

<div class="viewcode-block" id="dn2dlat">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.dn2dlat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dn2dlat</span><span class="p">(</span><span class="n">dn</span><span class="p">,</span><span class="n">lat</span><span class="p">):</span> <span class="k">return</span> <span class="n">dn</span> <span class="o">/</span> <span class="mi">111000</span></div>

<div class="viewcode-block" id="de2dlon">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.de2dlon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">de2dlon</span><span class="p">(</span><span class="n">de</span><span class="p">,</span><span class="n">lat</span><span class="p">):</span> <span class="k">return</span> <span class="n">de</span> <span class="o">/</span> <span class="p">(</span><span class="mi">111000</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="fdm">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.fdm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fdm</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span></div>

<div class="viewcode-block" id="utm_zone_from_latlon">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.utm_zone_from_latlon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">utm_zone_from_latlon</span><span class="p">(</span><span class="n">lat_deg</span><span class="p">,</span> <span class="n">lon_deg</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">lon_deg</span> <span class="o">+</span> <span class="mi">180</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lat_deg</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="transform_lla_to_utm">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.transform_lla_to_utm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform_lla_to_utm</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">,</span> <span class="n">lon_rad</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">is_north</span><span class="p">):</span>
        <span class="c1"># Simplified placeholder for pyproj or gdal</span>
        <span class="n">lat_deg</span><span class="p">,</span> <span class="n">lon_deg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">lon_rad</span><span class="p">)</span>
        <span class="c1"># This is NOT a real UTM conversion, just for structure</span>
        <span class="k">return</span> <span class="n">lon_deg</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">lat_deg</span> <span class="o">*</span> <span class="mi">1000</span></div>

<div class="viewcode-block" id="create_dcm_from_vel">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_dcm_from_vel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_dcm_from_vel</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span> <span class="n">ve</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">vn</span><span class="p">))</span></div>

<div class="viewcode-block" id="dcm2euler">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.dcm2euler">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dcm2euler</span><span class="p">(</span><span class="n">dcm</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dcm</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span> <span class="k">if</span> <span class="n">dcm</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="euler2dcm">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.euler2dcm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">euler2dcm</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span><span class="n">pitch</span><span class="p">,</span><span class="n">yaw</span><span class="p">,</span><span class="n">order</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">roll</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="create_ins_model_matrices">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_ins_model_matrices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_ins_model_matrices</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="c1"># P0, Qd, R</span></div>

<div class="viewcode-block" id="get_phi_matrix">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_phi_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_phi_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span></div>

<div class="viewcode-block" id="correct_cnb_matrix">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.correct_cnb_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correct_cnb_matrix</span><span class="p">(</span><span class="n">cnb</span><span class="p">,</span> <span class="n">err</span><span class="p">):</span> <span class="k">return</span> <span class="n">cnb</span></div>

<div class="viewcode-block" id="upward_fft_map">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.upward_fft_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">upward_fft_map</span><span class="p">(</span><span class="n">map_s</span><span class="p">,</span> <span class="n">alt</span><span class="p">):</span> <span class="k">return</span> <span class="n">map_s</span></div>

<div class="viewcode-block" id="get_map_params">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_map_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_map_params</span><span class="p">(</span><span class="n">map_s</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># ind0,ind1,_,_</span></div>

<div class="viewcode-block" id="fill_map_gaps">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.fill_map_gaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill_map_gaps</span><span class="p">(</span><span class="n">map_s</span><span class="p">):</span> <span class="k">return</span> <span class="n">map_s</span></div>

<div class="viewcode-block" id="trim_map">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.trim_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim_map</span><span class="p">(</span><span class="n">map_s</span><span class="p">):</span> <span class="k">return</span> <span class="n">map_s</span></div>

    <span class="c1"># def get_map_value_at_coords(map_s, lat, lon, alt, alpha=200, return_itp=False):</span>
    <span class="c1">#     if return_itp: return np.zeros(len(lat)), None</span>
    <span class="c1">#     return np.zeros(len(lat))</span>
<div class="viewcode-block" id="generate_fogm_noise">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.generate_fogm_noise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_fogm_noise</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span></div>

<div class="viewcode-block" id="create_tolles_lawson_A_matrix">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_tolles_lawson_A_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_tolles_lawson_A_matrix</span><span class="p">(</span><span class="n">Bx</span><span class="p">,</span><span class="n">By</span><span class="p">,</span><span class="n">Bz</span><span class="p">,</span><span class="n">terms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">Bx</span><span class="p">),</span> <span class="mi">18</span><span class="p">))</span> <span class="c1"># Dummy</span></div>

<div class="viewcode-block" id="get_igrf_magnetic_field">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_igrf_magnetic_field">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_igrf_magnetic_field</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="n">norm_igrf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_xyz</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_points</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">norm_igrf</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span></div>

<div class="viewcode-block" id="apply_band_pass_filter">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.apply_band_pass_filter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_band_pass_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bpf_coeffs</span><span class="p">):</span> <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="get_band_pass_filter_coeffs">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_band_pass_filter_coeffs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_band_pass_filter_coeffs</span><span class="p">(</span><span class="n">pass1</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span><span class="n">pass2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="tolles_lawson_coeffs_to_matrix">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.tolles_lawson_coeffs_to_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tolles_lawson_coeffs_to_matrix</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">Bt_scale</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span></div>

<div class="viewcode-block" id="get_tolles_lawson_aircraft_field_vector">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_tolles_lawson_aircraft_field_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_tolles_lawson_aircraft_field_vector</span><span class="p">(</span><span class="n">B_earth</span><span class="p">,</span> <span class="n">B_earth_dot</span><span class="p">,</span> <span class="n">c_p</span><span class="p">,</span> <span class="n">c_i</span><span class="p">,</span> <span class="n">c_e</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">B_earth</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_trajectory_subset">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_trajectory_subset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_trajectory_subset</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span> <span class="c1"># Simplified</span>
        <span class="k">return</span> <span class="n">Traj</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">dt</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">tt</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">tt</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">lat</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">lon</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">alt</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                    <span class="n">vn</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">vn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">ve</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">ve</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">vd</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">vd</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">fn</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">fn</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">fe</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">fe</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">fd</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">fd</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span>
                    <span class="n">Cnb</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">Cnb</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span></div>

<div class="viewcode-block" id="approximate_gradient">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.approximate_gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">approximate_gradient</span><span class="p">(</span><span class="n">itp_func</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span> <span class="c1"># Dummy</span></div>



<div class="viewcode-block" id="create_xyz0">
<a class="viewcode-back" href="../../data.html#magnavpy.create_xyz.create_xyz0">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_xyz0</span><span class="p">(</span>
    <span class="n">mapS</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">alt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">300.0</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">68.0</span><span class="p">,</span>
    <span class="n">ll1</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">ll2</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">N_waves</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Simulated data&quot;</span><span class="p">,</span>
    <span class="n">flight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2023</span><span class="p">,</span>
    <span class="n">doy</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">154</span><span class="p">,</span>
    <span class="n">mapV</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapV</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cor_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">cor_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">600.0</span><span class="p">,</span>
    <span class="n">cor_var</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="c1"># This is for compensated, but Julia has it duplicated</span>
    <span class="n">cor_drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">cor_perm_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="n">cor_ind_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="n">cor_eddy_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">init_pos_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="n">init_alt_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">init_vel_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">init_att_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>
    <span class="n">VRW_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000238</span><span class="p">,</span>
    <span class="n">ARW_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000000581</span><span class="p">,</span>
    <span class="n">baro_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">ha_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">a_hat_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">acc_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000245</span><span class="p">,</span>
    <span class="n">gyro_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.00000000727</span><span class="p">,</span>
    <span class="n">fogm_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="c1"># This is for compensated</span>
    <span class="n">baro_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">acc_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">gyro_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">fogm_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">600.0</span><span class="p">,</span> <span class="c1"># This is for compensated</span>
    <span class="n">save_h5</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">xyz_h5</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xyz_data.h5&quot;</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XYZ0</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create basic flight data. Assumes constant altitude (2D flight).</span>
<span class="sd">    Corresponds to create_XYZ0 in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mapS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapS</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_SCALAR_MAP_ID</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mapV</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapV</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_VECTOR_MAP_ID</span><span class="p">)</span>

    <span class="n">xyz_h5</span> <span class="o">=</span> <span class="n">add_extension</span><span class="p">(</span><span class="n">xyz_h5</span><span class="p">,</span> <span class="s2">&quot;.h5&quot;</span><span class="p">)</span>

    <span class="c1"># Create trajectory</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="n">create_traj</span><span class="p">(</span>
        <span class="n">mapS</span><span class="p">,</span>
        <span class="n">alt</span><span class="o">=</span><span class="n">alt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">ll1</span><span class="o">=</span><span class="n">ll1</span><span class="p">,</span> <span class="n">ll2</span><span class="o">=</span><span class="n">ll2</span><span class="p">,</span> <span class="n">N_waves</span><span class="o">=</span><span class="n">N_waves</span><span class="p">,</span>
        <span class="n">attempts</span><span class="o">=</span><span class="n">attempts</span><span class="p">,</span> <span class="n">save_h5</span><span class="o">=</span><span class="n">save_h5</span><span class="p">,</span> <span class="n">traj_h5</span><span class="o">=</span><span class="n">xyz_h5</span> <span class="c1"># Note: traj_h5 uses xyz_h5</span>
    <span class="p">)</span>

    <span class="c1"># Create INS</span>
    <span class="n">ins</span> <span class="o">=</span> <span class="n">create_ins</span><span class="p">(</span>
        <span class="n">traj</span><span class="p">,</span>
        <span class="n">init_pos_sigma</span><span class="o">=</span><span class="n">init_pos_sigma</span><span class="p">,</span> <span class="n">init_alt_sigma</span><span class="o">=</span><span class="n">init_alt_sigma</span><span class="p">,</span>
        <span class="n">init_vel_sigma</span><span class="o">=</span><span class="n">init_vel_sigma</span><span class="p">,</span> <span class="n">init_att_sigma</span><span class="o">=</span><span class="n">init_att_sigma</span><span class="p">,</span>
        <span class="n">VRW_sigma</span><span class="o">=</span><span class="n">VRW_sigma</span><span class="p">,</span> <span class="n">ARW_sigma</span><span class="o">=</span><span class="n">ARW_sigma</span><span class="p">,</span> <span class="n">baro_sigma</span><span class="o">=</span><span class="n">baro_sigma</span><span class="p">,</span>
        <span class="n">ha_sigma</span><span class="o">=</span><span class="n">ha_sigma</span><span class="p">,</span> <span class="n">a_hat_sigma</span><span class="o">=</span><span class="n">a_hat_sigma</span><span class="p">,</span> <span class="n">acc_sigma</span><span class="o">=</span><span class="n">acc_sigma</span><span class="p">,</span>
        <span class="n">gyro_sigma</span><span class="o">=</span><span class="n">gyro_sigma</span><span class="p">,</span> <span class="n">baro_tau</span><span class="o">=</span><span class="n">baro_tau</span><span class="p">,</span> <span class="n">acc_tau</span><span class="o">=</span><span class="n">acc_tau</span><span class="p">,</span>
        <span class="n">gyro_tau</span><span class="o">=</span><span class="n">gyro_tau</span><span class="p">,</span> <span class="n">save_h5</span><span class="o">=</span><span class="n">save_h5</span><span class="p">,</span> <span class="n">ins_h5</span><span class="o">=</span><span class="n">xyz_h5</span> <span class="c1"># Note: ins_h5 uses xyz_h5</span>
    <span class="p">)</span>

    <span class="c1"># Create compensated (clean) scalar magnetometer measurements</span>
    <span class="c1"># Julia&#39;s create_XYZ0 uses cor_var, fogm_sigma, fogm_tau for this.</span>
    <span class="n">mag_1_c</span> <span class="o">=</span> <span class="n">create_mag_c</span><span class="p">(</span>
        <span class="n">traj</span><span class="p">,</span> <span class="n">mapS</span><span class="p">,</span>
        <span class="n">meas_var</span><span class="o">=</span><span class="n">cor_var</span><span class="p">,</span> <span class="c1"># Using the general cor_var for compensated noise variance</span>
        <span class="n">fogm_sigma</span><span class="o">=</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="c1"># Using the general fogm_sigma for compensated FOGM</span>
        <span class="n">fogm_tau</span><span class="o">=</span><span class="n">fogm_tau</span><span class="p">,</span> <span class="c1"># Using the general fogm_tau for compensated FOGM</span>
        <span class="n">silent</span><span class="o">=</span><span class="n">silent</span>
    <span class="p">)</span>

    <span class="c1"># Create compensated (clean) vector magnetometer measurements</span>
    <span class="n">flux_a</span> <span class="o">=</span> <span class="n">create_flux</span><span class="p">(</span>
        <span class="n">traj</span><span class="p">,</span> <span class="n">mapV</span><span class="p">,</span>
        <span class="n">meas_var</span><span class="o">=</span><span class="n">cor_var</span><span class="p">,</span> <span class="c1"># Using the general cor_var</span>
        <span class="n">fogm_sigma</span><span class="o">=</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="c1"># Using the general fogm_sigma</span>
        <span class="n">fogm_tau</span><span class="o">=</span><span class="n">fogm_tau</span><span class="p">,</span> <span class="c1"># Using the general fogm_tau</span>
        <span class="n">silent</span><span class="o">=</span><span class="n">silent</span>
    <span class="p">)</span>

    <span class="c1"># Create uncompensated (corrupted) scalar magnetometer measurements</span>
    <span class="c1"># Julia&#39;s create_XYZ0 uses specific cor_ values for this.</span>
    <span class="n">mag_1_uc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">diurnal_effect</span> <span class="o">=</span> <span class="n">corrupt_mag</span><span class="p">(</span>
        <span class="n">mag_1_c</span><span class="p">,</span> <span class="n">flux_a</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">cor_sigma</span><span class="o">=</span><span class="n">cor_sigma</span><span class="p">,</span> <span class="n">cor_tau</span><span class="o">=</span><span class="n">cor_tau</span><span class="p">,</span> <span class="n">cor_var</span><span class="o">=</span><span class="n">cor_var</span><span class="p">,</span> <span class="c1"># These are the uncompensated specific ones</span>
        <span class="n">cor_drift</span><span class="o">=</span><span class="n">cor_drift</span><span class="p">,</span> <span class="n">cor_perm_mag</span><span class="o">=</span><span class="n">cor_perm_mag</span><span class="p">,</span>
        <span class="n">cor_ind_mag</span><span class="o">=</span><span class="n">cor_ind_mag</span><span class="p">,</span> <span class="n">cor_eddy_mag</span><span class="o">=</span><span class="n">cor_eddy_mag</span>
    <span class="p">)</span>

    <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
    <span class="n">flights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">flight</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">lines</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">years</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">doys</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_points</span><span class="p">,</span> <span class="n">doy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Placeholder for diurnal, assuming corrupt_mag returns it or it&#39;s calculated elsewhere.</span>
    <span class="c1"># In Julia, it&#39;s the third return from corrupt_mag.</span>
    <span class="n">diurnal</span> <span class="o">=</span> <span class="n">diurnal_effect</span> <span class="c1"># Or np.zeros(num_points) if not returned by corrupt_mag</span>

    <span class="c1"># Initialize IGRF, then calculate actual values</span>
    <span class="n">igrf_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
    
    <span class="c1"># Construct preliminary XYZ to pass to get_igrf</span>
    <span class="c1"># Note: This might require XYZ0 to allow partial initialization or a different approach</span>
    <span class="c1"># For now, assuming XYZ0 can be created with placeholder igrf</span>
    <span class="n">xyz_temp_fields</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="n">info</span><span class="p">,</span> <span class="s2">&quot;traj&quot;</span><span class="p">:</span> <span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;ins&quot;</span><span class="p">:</span> <span class="n">ins</span><span class="p">,</span> <span class="s2">&quot;flux_a&quot;</span><span class="p">:</span> <span class="n">flux_a</span><span class="p">,</span>
        <span class="s2">&quot;flights&quot;</span><span class="p">:</span> <span class="n">flights</span><span class="p">,</span> <span class="s2">&quot;lines&quot;</span><span class="p">:</span> <span class="n">lines</span><span class="p">,</span> <span class="s2">&quot;years&quot;</span><span class="p">:</span> <span class="n">years</span><span class="p">,</span> <span class="s2">&quot;doys&quot;</span><span class="p">:</span> <span class="n">doys</span><span class="p">,</span>
        <span class="s2">&quot;diurnal&quot;</span><span class="p">:</span> <span class="n">diurnal</span><span class="p">,</span> <span class="s2">&quot;igrf&quot;</span><span class="p">:</span> <span class="n">igrf_initial</span><span class="p">,</span> <span class="s2">&quot;mag_1_c&quot;</span><span class="p">:</span> <span class="n">mag_1_c</span><span class="p">,</span> <span class="s2">&quot;mag_1_uc&quot;</span><span class="p">:</span> <span class="n">mag_1_uc</span>
    <span class="p">}</span>
    <span class="c1"># This is a bit tricky. If XYZ0 is a strict dataclass, we might need to pass all args.</span>
    <span class="c1"># Let&#39;s assume get_igrf can work with a dictionary or a partially formed object,</span>
    <span class="c1"># or we make a temporary XYZ0 instance.</span>
    
    <span class="c1"># Simplification: Create XYZ0 first, then update igrf.</span>
    <span class="c1"># This requires all fields for XYZ0 constructor.</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">XYZ0</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span> <span class="n">ins</span><span class="o">=</span><span class="n">ins</span><span class="p">,</span> <span class="n">flux_a</span><span class="o">=</span><span class="n">flux_a</span><span class="p">,</span>
               <span class="n">flights</span><span class="o">=</span><span class="n">flights</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">years</span><span class="o">=</span><span class="n">years</span><span class="p">,</span> <span class="n">doys</span><span class="o">=</span><span class="n">doys</span><span class="p">,</span>
               <span class="n">diurnal</span><span class="o">=</span><span class="n">diurnal</span><span class="p">,</span> <span class="n">igrf</span><span class="o">=</span><span class="n">igrf_initial</span><span class="p">,</span> <span class="c1"># igrf_initial is placeholder</span>
               <span class="n">mag_1_c</span><span class="o">=</span><span class="n">mag_1_c</span><span class="p">,</span> <span class="n">mag_1_uc</span><span class="o">=</span><span class="n">mag_1_uc</span><span class="p">)</span>

    <span class="n">igrf_vector_body</span> <span class="o">=</span> <span class="n">get_igrf_magnetic_field</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="n">norm_igrf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">igrf_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">igrf_vector_body</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Assuming igrf_vector_body is 3xN</span>
    <span class="n">xyz</span><span class="o">.</span><span class="n">igrf</span> <span class="o">=</span> <span class="n">igrf_scalar</span>

    <span class="k">if</span> <span class="n">save_h5</span><span class="p">:</span>
        <span class="c1"># &#39;a&#39; mode: read/write if exists, create otherwise. Julia &#39;cw&#39; is similar.</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">xyz_h5</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># Overwrite if traj/ins already wrote some of these, or manage groups.</span>
            <span class="c1"># For simplicity, assuming direct write/overwrite at root or that</span>
            <span class="c1"># traj_h5/ins_h5 were different files or used groups.</span>
            <span class="c1"># If xyz_h5 is the *same* file, need to be careful about overwriting.</span>
            <span class="c1"># The Julia code implies it&#39;s the same file and appends/overwrites.</span>
            <span class="k">if</span> <span class="s2">&quot;flux_a_x&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flux_a_x&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">flux_a</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;flux_a_x&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">flux_a</span><span class="o">.</span><span class="n">x</span>
            <span class="k">if</span> <span class="s2">&quot;flux_a_y&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flux_a_y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">flux_a</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;flux_a_y&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">flux_a</span><span class="o">.</span><span class="n">y</span>
            <span class="k">if</span> <span class="s2">&quot;flux_a_z&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flux_a_z&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">flux_a</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;flux_a_z&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">flux_a</span><span class="o">.</span><span class="n">z</span>
            <span class="k">if</span> <span class="s2">&quot;flux_a_t&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flux_a_t&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">flux_a</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;flux_a_t&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">flux_a</span><span class="o">.</span><span class="n">t</span>
            
            <span class="k">if</span> <span class="s2">&quot;mag_1_uc&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;mag_1_uc&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">mag_1_uc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;mag_1_uc&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">mag_1_uc</span>
            <span class="k">if</span> <span class="s2">&quot;mag_1_c&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;mag_1_c&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">mag_1_c</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;mag_1_c&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">mag_1_c</span>
            
            <span class="k">if</span> <span class="s2">&quot;flight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;flight&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">flights</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;flight&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">flights</span>
            <span class="k">if</span> <span class="s2">&quot;line&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;line&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">lines</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;line&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">lines</span>
            <span class="k">if</span> <span class="s2">&quot;year&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">years</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">years</span>
            <span class="k">if</span> <span class="s2">&quot;doy&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;doy&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">doys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;doy&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">doys</span>
            <span class="k">if</span> <span class="s2">&quot;diurnal&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;diurnal&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">diurnal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;diurnal&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">diurnal</span>
            <span class="k">if</span> <span class="s2">&quot;igrf&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;igrf&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">xyz</span><span class="o">.</span><span class="n">igrf</span><span class="p">)</span> <span class="c1"># Use updated igrf</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;igrf&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">igrf</span>
    <span class="k">return</span> <span class="n">xyz</span></div>


<div class="viewcode-block" id="create_traj">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_traj">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_traj</span><span class="p">(</span>
    <span class="n">mapS</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span>
    <span class="n">alt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1000.0</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">300.0</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">68.0</span><span class="p">,</span>
    <span class="n">ll1</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">ll2</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">N_waves</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">save_h5</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">traj_h5</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;traj_data.h5&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Traj</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Traj trajectory struct with a straight or sinusoidal flight path.</span>
<span class="sd">    Corresponds to create_traj in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">traj_h5</span> <span class="o">=</span> <span class="n">add_extension</span><span class="p">(</span><span class="n">traj_h5</span><span class="p">,</span> <span class="s2">&quot;.h5&quot;</span><span class="p">)</span>

    <span class="c1"># Check flight altitude</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mapS</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mapS</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ensure mapS.alt is indexable by mapS.mask if mapS.alt is a grid</span>
        <span class="c1"># This part needs careful handling based on MapSd structure</span>
        <span class="c1"># Assuming mapS.alt is a 2D grid and mapS.mask is a boolean grid of same shape</span>
        <span class="n">valid_alts</span> <span class="o">=</span> <span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">mapS</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="k">if</span> <span class="n">mapS</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">)]</span> <span class="c1"># fallback</span>
        <span class="n">map_altitude_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">valid_alts</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_alts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">map_altitude_ref</span> <span class="o">=</span> <span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
         <span class="n">map_altitude_ref</span> <span class="o">=</span> <span class="n">mapS</span><span class="o">.</span><span class="n">alt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Fallback or error if mapS.alt structure is unknown</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine reference altitude from mapS&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">alt</span> <span class="o">&lt;</span> <span class="n">map_altitude_ref</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Flight altitude </span><span class="si">{</span><span class="n">alt</span><span class="si">}</span><span class="s2"> &lt; map reference altitude </span><span class="si">{</span><span class="n">map_altitude_ref</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N_pts</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Initial number of points for lat/lon arrays</span>
    <span class="n">lat_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_pts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">lon_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_pts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="c1"># Loop to find a valid trajectory</span>
    <span class="c1"># The condition `(not map_check(mapS, lat_path, lon_path) and i &lt;= attempts) or i == 0`</span>
    <span class="c1"># ensures at least one attempt and retries if path is not on map.</span>
    <span class="n">path_found_on_map</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">path_found_on_map</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attempts</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ll1</span><span class="p">:</span>  <span class="c1"># If ll1 is empty, put initial point in middle 50% of map</span>
            <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">yy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">yy</span><span class="p">)</span>
            <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">xx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span>
            <span class="c1"># Ensure mapS.yy and mapS.xx are in radians if subsequent calcs expect radians</span>
            <span class="c1"># Assuming they are already in radians as per typical geodetic calculations</span>
            <span class="n">lat1</span> <span class="o">=</span> <span class="n">lat_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">lat_max</span> <span class="o">-</span> <span class="n">lat_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="mf">0.50</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
            <span class="n">lon1</span> <span class="o">=</span> <span class="n">lon_min</span> <span class="o">+</span> <span class="p">(</span><span class="n">lon_max</span> <span class="o">-</span> <span class="n">lon_min</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="mf">0.50</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Use given initial point (degrees), convert to radians</span>
            <span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ll1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ll1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ll2</span><span class="p">:</span>  <span class="c1"># Use given velocity &amp; time to set distance</span>
            <span class="n">N_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">t</span>  <span class="c1"># distance</span>
            <span class="n">theta_utm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>  <span class="c1"># random heading</span>
            <span class="c1"># Convert distance and heading to lat/lon changes</span>
            <span class="c1"># These require geodetic calculations (e.g., Vincenty or simpler spherical model)</span>
            <span class="c1"># Using analysis_util helpers: dn2dlat, de2dlon</span>
            <span class="c1"># dn = dist * sin(theta_utm), de = dist * cos(theta_utm)</span>
            <span class="n">lat2</span> <span class="o">=</span> <span class="n">lat1</span> <span class="o">+</span> <span class="n">dn2dlat</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_utm</span><span class="p">),</span> <span class="n">lat1</span><span class="p">)</span>
            <span class="n">lon2</span> <span class="o">=</span> <span class="n">lon1</span> <span class="o">+</span> <span class="n">de2dlon</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_utm</span><span class="p">),</span> <span class="n">lat1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Use given final point directly</span>
            <span class="n">N_pts_est</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">N_waves</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Estimated N, to be corrected</span>
            <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ll2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ll2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># N_pts will be refined later based on actual path length and dt</span>

        <span class="n">dlat</span> <span class="o">=</span> <span class="n">lat2</span> <span class="o">-</span> <span class="n">lat1</span>
        <span class="n">dlon</span> <span class="o">=</span> <span class="n">lon2</span> <span class="o">-</span> <span class="n">lon1</span>
        <span class="n">theta_ll</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">dlat</span><span class="p">,</span> <span class="n">dlon</span><span class="p">)</span> <span class="c1"># Heading in lat/lon rad space (y,x)</span>

        <span class="c1"># Initial straight line path (or base for waves)</span>
        <span class="c1"># Use N_pts if ll2 is not set, or N_pts_est if ll2 is set (will be resampled)</span>
        <span class="n">current_N</span> <span class="o">=</span> <span class="n">N_pts</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">ll2</span> <span class="k">else</span> <span class="n">N_pts_est</span>
        <span class="n">lat_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">current_N</span><span class="p">)</span>
        <span class="n">lon_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">current_N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_waves</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">phi_waves</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_waves</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">current_N</span><span class="p">)</span>
            <span class="c1"># Wave amplitude needs to be determined. Julia&#39;s example doesn&#39;t specify amplitude.</span>
            <span class="c1"># Assuming a fraction of the path length or a fixed value.</span>
            <span class="c1"># The Julia code `wav = [ϕ sin.(ϕ)]` implies amplitude is 1 in ϕ units.</span>
            <span class="c1"># This needs to be scaled to geographic units.</span>
            <span class="c1"># The Julia code `cor = wav*rot&#39;` and then `lat = (cor[:,2] .- cor[1,2] .+ lat1)`</span>
            <span class="c1"># suggests the wave is applied to the parametric progression (phi) and then rotated.</span>
            <span class="c1"># This part is complex to translate directly without knowing wave amplitude scaling.</span>
            <span class="c1"># For now, a simplified placeholder or assuming amplitude is implicitly handled.</span>
            <span class="c1"># Let&#39;s assume the wave is a perturbation perpendicular to the path.</span>
            <span class="c1"># A common way is A * sin(phi_waves), where A is amplitude in radians.</span>
            <span class="c1"># The Julia code seems to make the path itself sinusoidal in the direction of travel.</span>
            <span class="c1"># `wav = [ϕ sin.(ϕ)]` -&gt; `wav_x = phi_waves`, `wav_y = np.sin(phi_waves)`</span>
            <span class="c1"># `rot = [[cos(θ_ll), -sin(θ_ll)], [sin(θ_ll), cos(θ_ll)]]`</span>
            <span class="c1"># `cor = np.dot(np.vstack((wav_x, wav_y)).T, rot.T)`</span>
            <span class="c1"># `lon_path = (cor[:,0] - cor[0,0]) + lon1`</span>
            <span class="c1"># `lat_path = (cor[:,1] - cor[0,1]) + lat1`</span>
            <span class="c1"># This interpretation makes the path itself a rotated sinusoid.</span>
            <span class="c1"># The Julia code `cor[:,2]` and `cor[:,1]` implies wav is (N,2) and rot is (2,2).</span>
            <span class="c1"># `wav = [ϕ sin.(ϕ)]` -&gt; `wav = np.column_stack((phi_waves, np.sin(phi_waves)))`</span>
            <span class="c1"># `rot_matrix = np.array([[math.cos(theta_ll), -math.sin(theta_ll)],</span>
            <span class="c1">#                          [math.sin(theta_ll), math.cos(theta_ll)]])`</span>
            <span class="c1"># `cor = np.dot(wav, rot_matrix.T)`</span>
            <span class="c1"># `lon_path = (cor[:,0] - cor[0,0]) + lon1` # Julia used cor[:,1] for lat, cor[:,2] for lon (1-indexed)</span>
            <span class="c1"># `lat_path = (cor[:,1] - cor[0,1]) + lat1` # Python: cor[:,0] for x-like, cor[:,1] for y-like</span>
            <span class="c1"># This seems to be the correct interpretation of Julia&#39;s 1-based indexing.</span>
            <span class="c1"># The amplitude of sin(phi) is 1. This needs scaling to meters or degrees.</span>
            <span class="c1"># The Julia code does not show explicit scaling of sin(phi).</span>
            <span class="c1"># This suggests the &quot;waviness&quot; is relative to the total length implicitly.</span>
            <span class="c1"># Re-evaluating: `lat = (cor[:,2] .- cor[1,2] .+ lat1)`</span>
            <span class="c1"># `lon = (cor[:,1] .- cor[1,1] .+ lon1)`</span>
            <span class="c1"># This means `cor` has columns for transformed x and y.</span>
            <span class="c1"># If `wav` is `[phi, sin(phi)]`, then `phi` is the along-track progress and `sin(phi)` is cross-track.</span>
            <span class="c1"># This part is tricky. A simpler approach for Python might be needed if direct translation is unclear.</span>
            <span class="c1"># For now, skipping the complex wave part for brevity, assuming straight line or simple wave.</span>
            <span class="c1"># If waves are critical, this needs more detailed translation.</span>
            <span class="k">pass</span> <span class="c1"># Simplified: waves not fully implemented here due to ambiguity in scaling.</span>

        <span class="c1"># Iteratively scale path to target distance or endpoint</span>
        <span class="c1"># This loop in Julia: `while !(frac1 ≈ 1) | !(frac2 ≈ 1)`</span>
        <span class="c1"># Python: `while not (np.isclose(frac1, 1.0) and np.isclose(frac2, 1.0)):` (approx)</span>
        <span class="c1"># For simplicity, let&#39;s assume a few iterations or direct calculation if possible.</span>
        <span class="c1"># The Julia code recalculates dx, dy, d_now inside this loop.</span>
        
        <span class="c1"># Calculate actual distance of the current path (lat_path, lon_path)</span>
        <span class="c1"># Using fdm and geodetic distance helpers</span>
        <span class="n">dx_m</span> <span class="o">=</span> <span class="n">dlon2de</span><span class="p">(</span><span class="n">fdm</span><span class="p">(</span><span class="n">lon_path</span><span class="p">),</span> <span class="n">lat_path</span><span class="p">)</span> <span class="c1"># Easting distances</span>
        <span class="n">dy_m</span> <span class="o">=</span> <span class="n">dlat2dn</span><span class="p">(</span><span class="n">fdm</span><span class="p">(</span><span class="n">lat_path</span><span class="p">),</span> <span class="n">lat_path</span><span class="p">)</span> <span class="c1"># Northing distances</span>
        <span class="c1"># fdm might return N points or N-1. Assuming N points, first is often 0 or NaN.</span>
        <span class="c1"># Distances are between points, so use diff or slice.</span>
        <span class="n">segment_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy_m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Skip first fdm element if it&#39;s an offset</span>
        <span class="n">current_total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">segment_distances</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ll2</span><span class="p">:</span> <span class="c1"># Scale to target distance `dist`</span>
            <span class="k">if</span> <span class="n">current_total_dist</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span> <span class="c1"># Avoid division by zero</span>
                <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">current_total_dist</span>
                <span class="c1"># Rescale lat_path, lon_path. This is non-trivial for curved paths.</span>
                <span class="c1"># Julia&#39;s approach: `lat = (lat .- lat[1])*frac1 .+ lat[1]`</span>
                <span class="c1"># This scales relative to the start point.</span>
                <span class="n">lat_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat_path</span> <span class="o">-</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale_factor</span> <span class="o">+</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">lon_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">lon_path</span> <span class="o">-</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale_factor</span> <span class="o">+</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Scale to target endpoint (lat2, lon2)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lat_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-9</span> <span class="p">:</span> <span class="c1"># Avoid div by zero</span>
                 <span class="n">scale_factor_lat</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat2</span> <span class="o">-</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">lat_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                 <span class="n">lat_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">lat_path</span> <span class="o">-</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale_factor_lat</span> <span class="o">+</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lon_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                 <span class="n">scale_factor_lon</span> <span class="o">=</span> <span class="p">(</span><span class="n">lon2</span> <span class="o">-</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">lon_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                 <span class="n">lon_path</span> <span class="o">=</span> <span class="p">(</span><span class="n">lon_path</span> <span class="o">-</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale_factor_lon</span> <span class="o">+</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Recalculate N_pts based on true distance and dt if ll2 was given</span>
        <span class="k">if</span> <span class="n">ll2</span><span class="p">:</span>
            <span class="n">dx_m</span> <span class="o">=</span> <span class="n">dlon2de</span><span class="p">(</span><span class="n">fdm</span><span class="p">(</span><span class="n">lon_path</span><span class="p">),</span> <span class="n">lat_path</span><span class="p">)</span>
            <span class="n">dy_m</span> <span class="o">=</span> <span class="n">dlat2dn</span><span class="p">(</span><span class="n">fdm</span><span class="p">(</span><span class="n">lat_path</span><span class="p">),</span> <span class="n">lat_path</span><span class="p">)</span>
            <span class="n">segment_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dy_m</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">true_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">segment_distances</span><span class="p">)</span>
            
            <span class="n">t_flight</span> <span class="o">=</span> <span class="n">true_dist</span> <span class="o">/</span> <span class="n">v</span> <span class="c1"># True time</span>
            <span class="n">N_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">t_flight</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># Correct number of time steps</span>
            
            <span class="c1"># Resample lat_path, lon_path to new N_pts</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span>
                <span class="n">current_progression</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_path</span><span class="p">))</span>
                <span class="n">new_progression</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N_pts</span><span class="p">)</span>
                <span class="n">interp_lat</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">current_progression</span><span class="p">,</span> <span class="n">lat_path</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
                <span class="n">interp_lon</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">current_progression</span><span class="p">,</span> <span class="n">lon_path</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
                <span class="n">lat_path</span> <span class="o">=</span> <span class="n">interp_lat</span><span class="p">(</span><span class="n">new_progression</span><span class="p">)</span>
                <span class="n">lon_path</span> <span class="o">=</span> <span class="n">interp_lon</span><span class="p">(</span><span class="n">new_progression</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Single point case</span>
                <span class="n">lat_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_pts</span><span class="p">,</span> <span class="n">lat_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">lon_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N_pts</span><span class="p">,</span> <span class="n">lon_path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t_flight</span> <span class="c1"># Update total time</span>

        <span class="n">path_found_on_map</span> <span class="o">=</span> <span class="n">map_check</span><span class="p">(</span><span class="n">mapS</span><span class="p">,</span> <span class="n">lat_path</span><span class="p">,</span> <span class="n">lon_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path_found_on_map</span><span class="p">:</span>
            <span class="k">break</span> <span class="c1"># Exit loop if valid path found</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path_found_on_map</span><span class="p">:</span> <span class="c1"># or i &gt; attempts</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Maximum attempts (</span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s2">) reached, could not create valid trajectory on map. Decrease t or increase v.&quot;</span><span class="p">)</span>

    <span class="c1"># Ensure lat_path, lon_path are set for the final N_pts</span>
    <span class="c1"># If ll2 was not set, N_pts was set from t/dt initially.</span>
    <span class="c1"># If ll2 was set, N_pts was refined.</span>
    
    <span class="c1"># UTM conversion using assumed helpers from analysis_util</span>
    <span class="c1"># These helpers should handle pyproj or gdal internally.</span>
    <span class="n">mean_lat_deg_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lat_path</span><span class="p">))</span>
    <span class="n">mean_lon_deg_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lon_path</span><span class="p">))</span>
    <span class="n">utm_zone_num</span><span class="p">,</span> <span class="n">utm_is_north</span> <span class="o">=</span> <span class="n">utm_zone_from_latlon</span><span class="p">(</span><span class="n">mean_lat_deg_traj</span><span class="p">,</span> <span class="n">mean_lon_deg_traj</span><span class="p">)</span>
    
    <span class="n">utms_x</span><span class="p">,</span> <span class="n">utms_y</span> <span class="o">=</span> <span class="n">transform_lla_to_utm</span><span class="p">(</span><span class="n">lat_path</span><span class="p">,</span> <span class="n">lon_path</span><span class="p">,</span> <span class="n">utm_zone_num</span><span class="p">,</span> <span class="n">utm_is_north</span><span class="p">)</span>

    <span class="c1"># Velocities &amp; specific forces from position</span>
    <span class="c1"># fdm (finite difference method) from analysis_util</span>
    <span class="n">vn</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">utms_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>  <span class="c1"># North velocity from UTM y</span>
    <span class="n">ve</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">utms_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>  <span class="c1"># East velocity from UTM x</span>
    <span class="n">vd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">lat_path</span><span class="p">)</span> <span class="c1"># Assuming constant altitude, so vd is zero</span>
    
    <span class="n">fn</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>      <span class="c1"># North specific force (acceleration)</span>
    <span class="n">fe</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">ve</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>      <span class="c1"># East specific force</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">vd</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">g_earth</span> <span class="c1"># Down specific force (includes gravity)</span>
    
    <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N_pts</span><span class="p">)</span> <span class="c1"># Time vector</span>

    <span class="c1"># DCM (body to navigation) from heading</span>
    <span class="c1"># create_dcm_from_vel and dcm2euler from analysis_util</span>
    <span class="n">Cnb_array</span> <span class="o">=</span> <span class="n">create_dcm_from_vel</span><span class="p">(</span><span class="n">vn</span><span class="p">,</span> <span class="n">ve</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;body2nav&#39;</span><span class="p">)</span> <span class="c1"># Returns N x 3 x 3</span>
    <span class="n">euler_angles</span> <span class="o">=</span> <span class="n">dcm2euler</span><span class="p">(</span><span class="n">Cnb_array</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;body2nav&#39;</span><span class="p">)</span> <span class="c1"># Returns N x 3 (roll, pitch, yaw)</span>
    <span class="n">roll_path</span>  <span class="o">=</span> <span class="n">euler_angles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pitch_path</span> <span class="o">=</span> <span class="n">euler_angles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">yaw_path</span>   <span class="o">=</span> <span class="n">euler_angles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">alt_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lat_path</span><span class="p">,</span> <span class="n">alt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save_h5</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">traj_h5</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span> <span class="c1"># Append mode</span>
            <span class="c1"># Create datasets if they don&#39;t exist, or overwrite if they do.</span>
            <span class="c1"># Grouping might be better if file is shared (e.g., file.require_group(&quot;traj&quot;))</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">data_arr</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;tt&quot;</span><span class="p">,</span> <span class="n">tt</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">lat_path</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">lon_path</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;alt&quot;</span><span class="p">,</span> <span class="n">alt_path</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vn&quot;</span><span class="p">,</span> <span class="n">vn</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ve&quot;</span><span class="p">,</span> <span class="n">ve</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;vd&quot;</span><span class="p">,</span> <span class="n">vd</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fn&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fe&quot;</span><span class="p">,</span> <span class="n">fe</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="n">fd</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;roll&quot;</span><span class="p">,</span> <span class="n">roll_path</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pitch&quot;</span><span class="p">,</span> <span class="n">pitch_path</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;yaw&quot;</span><span class="p">,</span> <span class="n">yaw_path</span><span class="p">)</span>
            <span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data_arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="n">key</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">data_arr</span>
                
    <span class="k">return</span> <span class="n">Traj</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N_pts</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">tt</span><span class="o">=</span><span class="n">tt</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">lat_path</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">lon_path</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="n">alt_path</span><span class="p">,</span>
                <span class="n">vn</span><span class="o">=</span><span class="n">vn</span><span class="p">,</span> <span class="n">ve</span><span class="o">=</span><span class="n">ve</span><span class="p">,</span> <span class="n">vd</span><span class="o">=</span><span class="n">vd</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">fn</span><span class="p">,</span> <span class="n">fe</span><span class="o">=</span><span class="n">fe</span><span class="p">,</span> <span class="n">fd</span><span class="o">=</span><span class="n">fd</span><span class="p">,</span> <span class="n">Cnb</span><span class="o">=</span><span class="n">Cnb_array</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_ins">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_ins">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_ins</span><span class="p">(</span>
    <span class="n">traj</span><span class="p">:</span> <span class="n">Traj</span><span class="p">,</span>
    <span class="n">init_pos_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">,</span>
    <span class="n">init_alt_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">init_vel_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">init_att_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.00001</span><span class="p">),</span> <span class="c1"># Julia default was 0.01, then changed to 0.00001</span>
    <span class="n">VRW_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000238</span><span class="p">,</span>
    <span class="n">ARW_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000000581</span><span class="p">,</span>
    <span class="n">baro_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">ha_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">a_hat_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">acc_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.000245</span><span class="p">,</span>
    <span class="n">gyro_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.00000000727</span><span class="p">,</span>
    <span class="n">baro_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">acc_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">gyro_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3600.0</span><span class="p">,</span>
    <span class="n">save_h5</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">ins_h5</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ins_data.h5&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">INS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an INS trajectory about a true trajectory using a Pinson error model.</span>
<span class="sd">    Corresponds to create_ins in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ins_h5</span> <span class="o">=</span> <span class="n">add_extension</span><span class="p">(</span><span class="n">ins_h5</span><span class="p">,</span> <span class="s2">&quot;.h5&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">N</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="mi">17</span>  <span class="c1"># Total state dimension for Pinson error model</span>

    <span class="c1"># Get initial covariance P0 and process noise Qd from analysis_util helper</span>
    <span class="n">P0</span><span class="p">,</span> <span class="n">Qd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">create_ins_model_matrices</span><span class="p">(</span> <span class="c1"># R (measurement noise) not used here</span>
        <span class="n">dt</span><span class="p">,</span> <span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1"># Initial latitude</span>
        <span class="n">init_pos_sigma</span><span class="o">=</span><span class="n">init_pos_sigma</span><span class="p">,</span> <span class="n">init_alt_sigma</span><span class="o">=</span><span class="n">init_alt_sigma</span><span class="p">,</span>
        <span class="n">init_vel_sigma</span><span class="o">=</span><span class="n">init_vel_sigma</span><span class="p">,</span> <span class="n">init_att_sigma</span><span class="o">=</span><span class="n">init_att_sigma</span><span class="p">,</span>
        <span class="n">VRW_sigma</span><span class="o">=</span><span class="n">VRW_sigma</span><span class="p">,</span> <span class="n">ARW_sigma</span><span class="o">=</span><span class="n">ARW_sigma</span><span class="p">,</span>
        <span class="n">baro_sigma</span><span class="o">=</span><span class="n">baro_sigma</span><span class="p">,</span> <span class="n">ha_sigma</span><span class="o">=</span><span class="n">ha_sigma</span><span class="p">,</span> <span class="n">a_hat_sigma</span><span class="o">=</span><span class="n">a_hat_sigma</span><span class="p">,</span>
        <span class="n">acc_sigma</span><span class="o">=</span><span class="n">acc_sigma</span><span class="p">,</span> <span class="n">gyro_sigma</span><span class="o">=</span><span class="n">gyro_sigma</span><span class="p">,</span>
        <span class="n">baro_tau</span><span class="o">=</span><span class="n">baro_tau</span><span class="p">,</span> <span class="n">acc_tau</span><span class="o">=</span><span class="n">acc_tau</span><span class="p">,</span> <span class="n">gyro_tau</span><span class="o">=</span><span class="n">gyro_tau</span><span class="p">,</span>
        <span class="n">fogm_state</span><span class="o">=</span><span class="kc">False</span> <span class="c1"># Assuming FOGM state is not part of this 17-state model</span>
    <span class="p">)</span>

    <span class="n">P_ins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span> <span class="c1"># Store covariance at each step</span>
    <span class="n">err_ins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">nx</span><span class="p">))</span>   <span class="c1"># Store error state at each step</span>

    <span class="n">P_ins</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">P0</span>
    <span class="c1"># Sample initial error from N(0, P0)</span>
    <span class="n">err_ins</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="n">P0</span><span class="p">)</span>
    
    <span class="c1"># Cholesky decomposition of Qd for sampling process noise: sqrt(Qd) * N(0,I)</span>
    <span class="c1"># Ensure Qd is positive definite. Add small epsilon if numerical issues.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Qd_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Qd</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="c1"># Add small diagonal offset if Qd is not positive definite</span>
        <span class="n">Qd_chol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Qd</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-12</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Get state transition matrix Phi from analysis_util helper</span>
        <span class="n">Phi_k</span> <span class="o">=</span> <span class="n">get_phi_matrix</span><span class="p">(</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">vn</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">ve</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">vd</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
            <span class="n">traj</span><span class="o">.</span><span class="n">fn</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">fe</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">fd</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">traj</span><span class="o">.</span><span class="n">Cnb</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:],</span> <span class="c1"># Cnb at step k</span>
            <span class="n">baro_tau</span><span class="p">,</span> <span class="n">acc_tau</span><span class="p">,</span> <span class="n">gyro_tau</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">fogm_state</span><span class="o">=</span><span class="kc">False</span> <span class="c1"># 0 for fogm_tau if no fogm_state</span>
        <span class="p">)</span>
        <span class="c1"># Propagate error state: err_k+1 = Phi_k * err_k + w_k</span>
        <span class="c1"># w_k ~ N(0, Qd), so sample as Qd_chol * N(0,I)</span>
        <span class="n">process_noise_k</span> <span class="o">=</span> <span class="n">Qd_chol</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">err_ins</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">Phi_k</span> <span class="o">@</span> <span class="n">err_ins</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">process_noise_k</span>
        
        <span class="c1"># Propagate covariance: P_k+1 = Phi_k * P_k * Phi_k^T + Qd</span>
        <span class="n">P_ins</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">Phi_k</span> <span class="o">@</span> <span class="n">P_ins</span><span class="p">[</span><span class="n">k</span><span class="p">,:,:]</span> <span class="o">@</span> <span class="n">Phi_k</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Qd</span>

    <span class="c1"># Apply errors to true trajectory to get INS trajectory</span>
    <span class="c1"># Error state definition (typical Pinson):</span>
    <span class="c1"># err[0:3] = pos_err (lat, lon, alt) -&gt; Julia used subtraction, so INS = True - Err</span>
    <span class="c1"># err[3:6] = vel_err (vn, ve, vd)</span>
    <span class="c1"># err[6:9] = att_err (psi_n, psi_e, psi_d) -&gt; tilt errors</span>
    <span class="c1"># err[9:12]= acc_bias</span>
    <span class="c1"># err[12:15]=gyro_bias</span>
    <span class="c1"># err[15] = baro_bias</span>
    <span class="c1"># err[16] = baro_scale_factor (or other, depending on model variant)</span>
    
    <span class="c1"># Note: Julia subtracts error: lat = traj.lat - err[0,:]. If err is (true-estimate), then estimate = true - err.</span>
    <span class="c1"># If err is (estimate-true), then estimate = true + err.</span>
    <span class="c1"># Assuming err_ins represents (true - ins_estimate) for position/velocity,</span>
    <span class="c1"># or (ins_estimate - true) for biases.</span>
    <span class="c1"># The Julia code `lat = traj.lat - err[0,:]` implies err[0] is (true_lat - ins_lat).</span>
    <span class="c1"># So, ins_lat = traj.lat - err_pos_lat. This seems consistent.</span>
    
    <span class="n">ins_lat</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">lat</span> <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ins_lon</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">lon</span> <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ins_alt</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">alt</span> <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ins_vn</span>  <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">vn</span>  <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">ins_ve</span>  <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">ve</span>  <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">ins_vd</span>  <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">vd</span>  <span class="o">-</span> <span class="n">err_ins</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span>

    <span class="c1"># Recalculate specific forces from INS velocities</span>
    <span class="n">ins_fn</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">ins_vn</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">ins_fe</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">ins_ve</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">ins_fd</span> <span class="o">=</span> <span class="n">fdm</span><span class="p">(</span><span class="n">ins_vd</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">g_earth</span>

    <span class="c1"># Correct Cnb using attitude errors (err_ins[:,6:9])</span>
    <span class="c1"># correct_cnb_matrix from analysis_util</span>
    <span class="c1"># Julia used -err[7:9,:], so if err_att is (true_att - ins_att), then ins_att = true_att - err_att.</span>
    <span class="c1"># Cnb_ins = Cnb_true * (I - skew(err_att_ins))</span>
    <span class="n">ins_Cnb</span> <span class="o">=</span> <span class="n">correct_cnb_matrix</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">Cnb</span><span class="p">,</span> <span class="o">-</span><span class="n">err_ins</span><span class="p">[:,</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># Pass err_att (3xN)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ins_Cnb</span> <span class="o">&gt;</span> <span class="mf">1.00001</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ins_Cnb</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.00001</span><span class="p">):</span> <span class="c1"># Add tolerance for float precision</span>
        <span class="c1"># This check might be too strict for floating point DCMs.</span>
        <span class="c1"># Consider checking orthogonality or determinant instead if issues arise.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: INS Cnb matrix out of expected bounds [-1, 1].&quot;</span><span class="p">)</span>
        <span class="c1"># raise ValueError(&quot;create_ins() failed, Cnb out of bounds. Re-run or check trajectory.&quot;)</span>

    <span class="n">ins_euler_angles</span> <span class="o">=</span> <span class="n">dcm2euler</span><span class="p">(</span><span class="n">ins_Cnb</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;body2nav&#39;</span><span class="p">)</span>
    <span class="n">ins_roll</span>  <span class="o">=</span> <span class="n">ins_euler_angles</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ins_pitch</span> <span class="o">=</span> <span class="n">ins_euler_angles</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ins_yaw</span>   <span class="o">=</span> <span class="n">ins_euler_angles</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">save_h5</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">ins_h5</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">data_arr</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;ins_tt&quot;</span><span class="p">,</span> <span class="n">traj</span><span class="o">.</span><span class="n">tt</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_lat&quot;</span><span class="p">,</span> <span class="n">ins_lat</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_lon&quot;</span><span class="p">,</span> <span class="n">ins_lon</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_alt&quot;</span><span class="p">,</span> <span class="n">ins_alt</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ins_vn&quot;</span><span class="p">,</span> <span class="n">ins_vn</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_ve&quot;</span><span class="p">,</span> <span class="n">ins_ve</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_vd&quot;</span><span class="p">,</span> <span class="n">ins_vd</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ins_fn&quot;</span><span class="p">,</span> <span class="n">ins_fn</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_fe&quot;</span><span class="p">,</span> <span class="n">ins_fe</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_fd&quot;</span><span class="p">,</span> <span class="n">ins_fd</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ins_roll&quot;</span><span class="p">,</span> <span class="n">ins_roll</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_pitch&quot;</span><span class="p">,</span> <span class="n">ins_pitch</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ins_yaw&quot;</span><span class="p">,</span> <span class="n">ins_yaw</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ins_P&quot;</span><span class="p">,</span> <span class="n">P_ins</span><span class="p">)</span> <span class="c1"># Save covariance history</span>
            <span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span> <span class="n">file</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data_arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">file</span><span class="p">[</span><span class="n">key</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">data_arr</span>
                
    <span class="k">return</span> <span class="n">INS</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">tt</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">tt</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="n">ins_lat</span><span class="p">,</span> <span class="n">lon</span><span class="o">=</span><span class="n">ins_lon</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="n">ins_alt</span><span class="p">,</span>
               <span class="n">vn</span><span class="o">=</span><span class="n">ins_vn</span><span class="p">,</span> <span class="n">ve</span><span class="o">=</span><span class="n">ins_ve</span><span class="p">,</span> <span class="n">vd</span><span class="o">=</span><span class="n">ins_vd</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="n">ins_fn</span><span class="p">,</span> <span class="n">fe</span><span class="o">=</span><span class="n">ins_fe</span><span class="p">,</span> <span class="n">fd</span><span class="o">=</span><span class="n">ins_fd</span><span class="p">,</span>
               <span class="n">Cnb</span><span class="o">=</span><span class="n">ins_Cnb</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P_ins</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_mag_c">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_mag_c">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_mag_c</span><span class="p">(</span>
    <span class="n">path_or_lat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">lon_or_mapS</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]],</span>
    <span class="n">mapS_if_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">alt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Used if lat,lon are inputs</span>
    <span class="n">dt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>   <span class="c1"># Used if lat,lon are inputs</span>
    <span class="n">meas_var</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fogm_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">fogm_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">600.0</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create compensated (clean) scalar magnetometer measurements.</span>
<span class="sd">    Overloaded: (lat, lon, mapS, ...) or (path, mapS, ...)</span>
<span class="sd">    Corresponds to create_mag_c in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_or_lat</span><span class="p">,</span> <span class="p">(</span><span class="n">Traj</span><span class="p">,</span> <span class="n">INS</span><span class="p">)):</span> <span class="c1"># Path object</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path_or_lat</span>
        <span class="n">mapS_actual</span> <span class="o">=</span> <span class="n">lon_or_mapS</span> <span class="c1"># mapS is the second arg in this case</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS_actual</span><span class="p">,</span> <span class="p">(</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)):</span>
             <span class="k">if</span> <span class="n">mapS_actual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mapS_actual</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_SCALAR_MAP_ID</span><span class="p">)</span>
             <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mapS_actual must be a MapS, MapSd, or MapS3D object when path is provided.&quot;</span><span class="p">)</span>

        <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lat</span>
        <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lon</span>
        <span class="c1"># Use median altitude from path if alt not explicitly overridden by user (though not an option here)</span>
        <span class="n">alt_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
        <span class="n">dt_val</span>  <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">dt</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_or_lat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon_or_mapS</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># lat, lon arrays</span>
        <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">path_or_lat</span>
        <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">lon_or_mapS</span>
        <span class="n">mapS_actual</span> <span class="o">=</span> <span class="n">mapS_if_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS_actual</span><span class="p">,</span> <span class="p">(</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">mapS_actual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mapS_actual</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_SCALAR_MAP_ID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mapS_actual must be a MapS, MapSd, or MapS3D object.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">alt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alt and dt must be provided when giving lat, lon arrays.&quot;</span><span class="p">)</span>
        <span class="n">alt_val</span> <span class="o">=</span> <span class="n">alt</span>
        <span class="n">dt_val</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arguments for create_mag_c. Provide (Path, MapS) or (lat_arr, lon_arr, MapS).&quot;</span><span class="p">)</span>

    <span class="c1"># Convert MapS3D to MapS at specified altitude if necessary</span>
    <span class="c1"># upward_fft_map from analysis_util</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapS_actual</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">):</span>
        <span class="n">mapS_actual</span> <span class="o">=</span> <span class="n">upward_fft_map</span><span class="p">(</span><span class="n">mapS_actual</span><span class="p">,</span> <span class="n">alt_val</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    
    <span class="c1"># map_params, fill_map_gaps, trim_map from analysis_util</span>
    <span class="c1"># These steps ensure the map is suitable for value extraction.</span>
    <span class="c1"># The Julia code checks `sum(ind0)/sum(ind0+ind1) &gt; 0.01` for filling.</span>
    <span class="c1"># This implies `map_params` returns info about filled/unfilled portions.</span>
    <span class="c1"># Assuming these util functions handle such logic.</span>
    <span class="c1"># ind0, ind1, _, _ = get_map_params(mapS_actual) # If needed for explicit check</span>
    <span class="c1"># if sum(ind0) / (sum(ind0) + sum(ind1)) &gt; 0.01: # Simplified logic</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info: preparing scalar map (filling/trimming if necessary).&quot;</span><span class="p">)</span>
    <span class="n">mapS_processed</span> <span class="o">=</span> <span class="n">fill_map_gaps</span><span class="p">(</span><span class="n">trim_map</span><span class="p">(</span><span class="n">mapS_actual</span><span class="p">))</span> <span class="c1"># Chain operations</span>

    <span class="c1"># Get map values along trajectory</span>
    <span class="c1"># get_map_value_at_coords from analysis_util</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info: getting scalar map values (upward/downward continuation if needed).&quot;</span><span class="p">)</span>
    <span class="n">map_values_scalar</span> <span class="o">=</span> <span class="n">get_map_val</span><span class="p">(</span><span class="n">mapS_processed</span><span class="p">,</span> <span class="n">lat_rad</span><span class="p">,</span> <span class="n">lon_rad</span><span class="p">,</span> <span class="n">alt_val</span><span class="p">)</span>

    <span class="c1"># Add FOGM &amp; white noise</span>
    <span class="c1"># generate_fogm_noise from analysis_util</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info: adding FOGM &amp; white noise to scalar map values.&quot;</span><span class="p">)</span>
    <span class="n">fogm_noise_scalar</span> <span class="o">=</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="n">fogm_tau</span><span class="p">,</span> <span class="n">dt_val</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">white_noise_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">meas_var</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    
    <span class="n">mag_c_values</span> <span class="o">=</span> <span class="n">map_values_scalar</span> <span class="o">+</span> <span class="n">fogm_noise_scalar</span> <span class="o">+</span> <span class="n">white_noise_scalar</span>
    
    <span class="k">return</span> <span class="n">mag_c_values</span></div>



<div class="viewcode-block" id="corrupt_mag">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.corrupt_mag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">corrupt_mag</span><span class="p">(</span>
    <span class="n">mag_c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">flux_or_Bx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MagV</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="c1"># MagV object or Bx array</span>
    <span class="n">By_if_coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">Bz_if_coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">cor_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">cor_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">600.0</span><span class="p">,</span>
    <span class="n">cor_var</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">cor_drift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">cor_perm_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="c1"># Std dev for permanent TL coefs</span>
    <span class="n">cor_ind_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>  <span class="c1"># Std dev for induced TL coefs</span>
    <span class="n">cor_eddy_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Std dev for eddy current TL coefs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corrupt compensated scalar mag data with FOGM, drift, and Tolles-Lawson noise.</span>
<span class="sd">    Overloaded: (mag_c, flux_obj, ...) or (mag_c, Bx, By, Bz, ...)</span>
<span class="sd">    Returns (mag_uc, TL_coefficients, corruption_FOGM_noise)</span>
<span class="sd">    Corresponds to corrupt_mag in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux_or_Bx</span><span class="p">,</span> <span class="n">MagV</span><span class="p">):</span>
        <span class="n">flux_obj</span> <span class="o">=</span> <span class="n">flux_or_Bx</span>
        <span class="n">Bx_vals</span><span class="p">,</span> <span class="n">By_vals</span><span class="p">,</span> <span class="n">Bz_vals</span> <span class="o">=</span> <span class="n">flux_obj</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">flux_obj</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">flux_obj</span><span class="o">.</span><span class="n">z</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux_or_Bx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> \
         <span class="nb">isinstance</span><span class="p">(</span><span class="n">By_if_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> \
         <span class="nb">isinstance</span><span class="p">(</span><span class="n">Bz_if_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">Bx_vals</span><span class="p">,</span> <span class="n">By_vals</span><span class="p">,</span> <span class="n">Bz_vals</span> <span class="o">=</span> <span class="n">flux_or_Bx</span><span class="p">,</span> <span class="n">By_if_coords</span><span class="p">,</span> <span class="n">Bz_if_coords</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arguments for corrupt_mag. Provide (mag_c, MagV_obj) or (mag_c, Bx, By, Bz).&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_c</span><span class="p">)</span>

    <span class="c1"># Tolles-Lawson coefficients are sampled from N(0, P)</span>
    <span class="c1"># P is diagonal with variances: perm^2 (3 terms), ind^2 (6 terms), eddy^2 (9 terms)</span>
    <span class="c1"># Total 3+6+9 = 18 coefficients for standard TL model.</span>
    <span class="n">tl_variances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
        <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cor_perm_mag</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">cor_ind_mag</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">cor_eddy_mag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">])</span>
    <span class="n">P_tl_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">tl_variances</span><span class="p">)</span>
    
    <span class="c1"># Sample TL coefficients</span>
    <span class="c1"># Ensure mean is explicitly zero for multivariate_normal</span>
    <span class="n">tl_coefficients</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tl_variances</span><span class="p">)),</span> <span class="n">cov</span><span class="o">=</span><span class="n">P_tl_cov</span><span class="p">)</span>

    <span class="c1"># FOGM noise for corruption</span>
    <span class="n">corruption_fogm_noise</span> <span class="o">=</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">cor_sigma</span><span class="p">,</span> <span class="n">cor_tau</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1"># White noise for corruption</span>
    <span class="n">corruption_white_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cor_var</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    
    <span class="c1"># Linear drift for corruption</span>
    <span class="c1"># Julia: cor_drift*rand()*(0:dt:dt*(N-1)) -&gt; single random scale for whole drift</span>
    <span class="n">time_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">corruption_drift</span> <span class="o">=</span> <span class="n">cor_drift</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="n">time_vector</span>
    
    <span class="n">mag_uc_intermediate</span> <span class="o">=</span> <span class="n">mag_c</span> <span class="o">+</span> <span class="n">corruption_white_noise</span> <span class="o">+</span> <span class="n">corruption_fogm_noise</span> <span class="o">+</span> <span class="n">corruption_drift</span>

    <span class="c1"># Add Tolles-Lawson aircraft field contribution if Bx,By,Bz are non-zero</span>
    <span class="c1"># create_tolles_lawson_A_matrix from analysis_util</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Bx_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">By_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">Bz_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">A_tl</span> <span class="o">=</span> <span class="n">create_tolles_lawson_A_matrix</span><span class="p">(</span><span class="n">Bx_vals</span><span class="p">,</span> <span class="n">By_vals</span><span class="p">,</span> <span class="n">Bz_vals</span><span class="p">)</span> <span class="c1"># Uses all terms by default</span>
        <span class="c1"># A_tl should be N x 18. tl_coefficients is 18.</span>
        <span class="c1"># TL effect is A_tl @ tl_coefficients</span>
        <span class="k">if</span> <span class="n">A_tl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tl_coefficients</span><span class="p">):</span> <span class="c1"># Check compatibility</span>
             <span class="n">tl_effect_on_scalar</span> <span class="o">=</span> <span class="n">A_tl</span> <span class="o">@</span> <span class="n">tl_coefficients</span>
             <span class="n">mag_uc_final</span> <span class="o">=</span> <span class="n">mag_uc_intermediate</span> <span class="o">+</span> <span class="n">tl_effect_on_scalar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: TL matrix columns </span><span class="si">{</span><span class="n">A_tl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> != TL coeffs </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tl_coefficients</span><span class="p">)</span><span class="si">}</span><span class="s2">. Skipping TL effect.&quot;</span><span class="p">)</span>
            <span class="n">mag_uc_final</span> <span class="o">=</span> <span class="n">mag_uc_intermediate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mag_uc_final</span> <span class="o">=</span> <span class="n">mag_uc_intermediate</span>
        
    <span class="k">return</span> <span class="n">mag_uc_final</span><span class="p">,</span> <span class="n">tl_coefficients</span><span class="p">,</span> <span class="n">corruption_fogm_noise</span></div>



<div class="viewcode-block" id="create_flux">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_flux">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_flux</span><span class="p">(</span>
    <span class="n">path_or_lat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">lon_or_mapV</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">MapV</span><span class="p">],</span>
    <span class="n">mapV_if_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapV</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">Cnb_if_coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># N x 3 x 3, used if lat,lon are inputs</span>
    <span class="n">alt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Used if lat,lon are inputs</span>
    <span class="n">dt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>   <span class="c1"># Used if lat,lon are inputs</span>
    <span class="n">meas_var</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">fogm_sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">fogm_tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">600.0</span><span class="p">,</span>
    <span class="n">silent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MagV</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create compensated (clean) vector magnetometer measurements (fluxgate).</span>
<span class="sd">    Overloaded: (path, mapV, ...) or (lat, lon, mapV, Cnb, alt, dt, ...)</span>
<span class="sd">    Corresponds to create_flux in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_or_lat</span><span class="p">,</span> <span class="p">(</span><span class="n">Traj</span><span class="p">,</span> <span class="n">INS</span><span class="p">)):</span> <span class="c1"># Path object</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path_or_lat</span>
        <span class="n">mapV_actual</span> <span class="o">=</span> <span class="n">lon_or_mapV</span> <span class="c1"># mapV is the second arg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapV_actual</span><span class="p">,</span> <span class="n">MapV</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mapV_actual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mapV_actual</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_VECTOR_MAP_ID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mapV_actual must be a MapV object when path is provided.&quot;</span><span class="p">)</span>

        <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lat</span>
        <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lon</span>
        <span class="n">Cnb_val</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">Cnb</span> <span class="c1"># N x 3 x 3</span>
        <span class="n">alt_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
        <span class="n">dt_val</span>  <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">dt</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_or_lat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon_or_mapV</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># lat, lon arrays</span>
        <span class="n">lat_rad</span> <span class="o">=</span> <span class="n">path_or_lat</span>
        <span class="n">lon_rad</span> <span class="o">=</span> <span class="n">lon_or_mapV</span>
        <span class="n">mapV_actual</span> <span class="o">=</span> <span class="n">mapV_if_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapV_actual</span><span class="p">,</span> <span class="n">MapV</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mapV_actual</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">mapV_actual</span> <span class="o">=</span> <span class="n">get_map</span><span class="p">(</span><span class="n">DEFAULT_VECTOR_MAP_ID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mapV_actual must be a MapV object.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">Cnb_if_coords</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">alt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cnb, alt, and dt must be provided when giving lat, lon arrays.&quot;</span><span class="p">)</span>
        <span class="n">Cnb_val</span> <span class="o">=</span> <span class="n">Cnb_if_coords</span>
        <span class="n">alt_val</span> <span class="o">=</span> <span class="n">alt</span>
        <span class="n">dt_val</span> <span class="o">=</span> <span class="n">dt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arguments for create_flux. Provide (Path, MapV) or (lat, lon, MapV, Cnb, ...).&quot;</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat_rad</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Cnb_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">N</span> <span class="ow">or</span> <span class="n">Cnb_val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="c1"># If Cnb is single 3x3, tile it. Julia default was repeat(I(3),1,1,N)</span>
        <span class="k">if</span> <span class="n">Cnb_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="c1"># Single DCM provided</span>
            <span class="n">Cnb_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Cnb_val</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Cnb_val</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="c1"># No points, but Cnb given</span>
             <span class="k">pass</span> <span class="c1"># Cnb_val is fine, loops won&#39;t run</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cnb shape </span><span class="si">{</span><span class="n">Cnb_val</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> inconsistent with N=</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> points.&quot;</span><span class="p">)</span>


    <span class="c1"># Get vector map values (Bx_nav, By_nav, Bz_nav) along trajectory</span>
    <span class="c1"># get_map_value_at_coords for MapV should return a tuple of 3 arrays or similar</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info: getting vector map values (upward/downward continuation if needed).&quot;</span><span class="p">)</span>
    <span class="c1"># Assuming get_map_value_at_coords for MapV returns tuple (Bx_nav, By_nav, Bz_nav)</span>
    <span class="n">map_values_vector_nav</span> <span class="o">=</span> <span class="n">get_map_val</span><span class="p">(</span><span class="n">mapV_actual</span><span class="p">,</span> <span class="n">lat_rad</span><span class="p">,</span> <span class="n">lon_rad</span><span class="p">,</span> <span class="n">alt_val</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">map_values_vector_nav</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_values_vector_nav</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;get_map_value_at_coords for MapV did not return 3 vector components.&quot;</span><span class="p">)</span>
    <span class="n">Bx_nav</span><span class="p">,</span> <span class="n">By_nav</span><span class="p">,</span> <span class="n">Bz_nav</span> <span class="o">=</span> <span class="n">map_values_vector_nav</span>

    <span class="c1"># Add FOGM &amp; white noise to each component</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Info: adding FOGM &amp; white noise to vector map values.&quot;</span><span class="p">)</span>
    <span class="n">noise_std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">meas_var</span><span class="p">)</span>
    <span class="n">Bx_nav_noisy</span> <span class="o">=</span> <span class="n">Bx_nav</span> <span class="o">+</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="n">fogm_tau</span><span class="p">,</span> <span class="n">dt_val</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_std_dev</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">By_nav_noisy</span> <span class="o">=</span> <span class="n">By_nav</span> <span class="o">+</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="n">fogm_tau</span><span class="p">,</span> <span class="n">dt_val</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_std_dev</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">Bz_nav_noisy</span> <span class="o">=</span> <span class="n">Bz_nav</span> <span class="o">+</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">fogm_sigma</span><span class="p">,</span> <span class="n">fogm_tau</span><span class="p">,</span> <span class="n">dt_val</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise_std_dev</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    
    <span class="c1"># Total field magnitude in navigation frame (before rotation to body)</span>
    <span class="n">Bt_nav_noisy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Bx_nav_noisy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By_nav_noisy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Bz_nav_noisy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Rotate measurements from navigation to body frame: B_body = Cnb^T * B_nav</span>
    <span class="c1"># Cnb is body to nav, so Cnb.T is nav to body.</span>
    <span class="n">Bx_body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">By_body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">Bz_body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">B_nav_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Bx_nav_noisy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">By_nav_noisy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Bz_nav_noisy</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="c1"># Cnb_val[i] is C_body_nav for point i. Cnb_val[i].T is C_nav_body</span>
        <span class="n">B_body_i</span> <span class="o">=</span> <span class="n">Cnb_val</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B_nav_i</span>
        <span class="n">Bx_body</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">By_body</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Bz_body</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_body_i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B_body_i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B_body_i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
    <span class="c1"># Total field magnitude in body frame (should be same as Bt_nav_noisy if rotation is correct)</span>
    <span class="n">Bt_body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Bx_body</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By_body</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Bz_body</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Assert or check if Bt_body is close to Bt_nav_noisy as a sanity check.</span>
    <span class="c1"># if N &gt; 0 and not np.allclose(Bt_body, Bt_nav_noisy):</span>
    <span class="c1">#    print(&quot;Warning: Total field magnitude changed after rotation to body frame.&quot;)</span>

    <span class="k">return</span> <span class="n">MagV</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">Bx_body</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">By_body</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">Bz_body</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">Bt_body</span><span class="p">)</span></div>



<div class="viewcode-block" id="create_dcm_internal">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_dcm_internal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_dcm_internal</span><span class="p">(</span> <span class="c1"># Renamed from create_dcm to avoid conflict if there&#39;s a main one</span>
    <span class="n">vn</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ve</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;body2nav&#39;</span> <span class="c1"># :body2nav or :nav2body</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal helper to estimate DCM using known heading with FOGM noise.</span>
<span class="sd">    Corresponds to create_dcm in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span>
    <span class="c1"># FOGM noise parameters from Julia code (hardcoded)</span>
    <span class="n">roll_fogm_std_rad</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">pitch_fogm_std_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">yaw_fogm_std_rad</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">fogm_tau_attitude</span>  <span class="o">=</span> <span class="mf">2.0</span> <span class="c1"># seconds</span>

    <span class="n">roll_noise</span>  <span class="o">=</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">roll_fogm_std_rad</span><span class="p">,</span>  <span class="n">fogm_tau_attitude</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">pitch_noise</span> <span class="o">=</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">pitch_fogm_std_rad</span><span class="p">,</span> <span class="n">fogm_tau_attitude</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">yaw_noise</span>   <span class="o">=</span> <span class="n">generate_fogm_noise</span><span class="p">(</span><span class="n">yaw_fogm_std_rad</span><span class="p">,</span>   <span class="n">fogm_tau_attitude</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1"># Band-pass filter for attitude noise (from analysis_util)</span>
    <span class="c1"># Julia: bpf = get_bpf(;pass1=1e-6,pass2=1)</span>
    <span class="n">bpf_coeffs</span> <span class="o">=</span> <span class="n">get_band_pass_filter_coeffs</span><span class="p">(</span><span class="n">pass1</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">pass2</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="c1"># Assuming 1 Hz upper for attitude</span>
    
    <span class="n">roll_filt</span>  <span class="o">=</span> <span class="n">apply_band_pass_filter</span><span class="p">(</span><span class="n">roll_noise</span><span class="p">,</span> <span class="n">bpf_coeffs</span><span class="o">=</span><span class="n">bpf_coeffs</span><span class="p">)</span>
    <span class="n">pitch_filt</span> <span class="o">=</span> <span class="n">apply_band_pass_filter</span><span class="p">(</span><span class="n">pitch_noise</span><span class="p">,</span> <span class="n">bpf_coeffs</span><span class="o">=</span><span class="n">bpf_coeffs</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="c1"># Pitch bias</span>
    
    <span class="c1"># Yaw definition from velocities (heading) + filtered noise</span>
    <span class="c1"># atan2(ve, vn) gives heading angle (from North, positive East)</span>
    <span class="n">heading_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">ve</span><span class="p">,</span> <span class="n">vn</span><span class="p">)</span>
    <span class="n">yaw_filt</span> <span class="o">=</span> <span class="n">apply_band_pass_filter</span><span class="p">(</span><span class="n">yaw_noise</span><span class="p">,</span> <span class="n">bpf_coeffs</span><span class="o">=</span><span class="n">bpf_coeffs</span><span class="p">)</span> <span class="o">+</span> <span class="n">heading_rad</span>
    
    <span class="c1"># Convert Euler angles (roll, pitch, yaw) to DCM</span>
    <span class="c1"># euler2dcm from analysis_util</span>
    <span class="n">dcm_array</span> <span class="o">=</span> <span class="n">euler2dcm</span><span class="p">(</span><span class="n">roll_filt</span><span class="p">,</span> <span class="n">pitch_filt</span><span class="p">,</span> <span class="n">yaw_filt</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="c1"># N x 3 x 3</span>
    
    <span class="k">return</span> <span class="n">dcm_array</span></div>



<div class="viewcode-block" id="calculate_imputed_TL_earth">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.calculate_imputed_TL_earth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_imputed_TL_earth</span><span class="p">(</span>
    <span class="n">xyz</span><span class="p">:</span> <span class="n">XYZ0</span><span class="p">,</span> <span class="c1"># Assuming XYZ0 or a compatible type</span>
    <span class="n">ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="c1"># Indices for the subset of data</span>
    <span class="n">map_val_scalar</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="c1"># Scalar magnetic anomaly map values for these indices</span>
    <span class="n">set_igrf_in_xyz</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">TL_coef</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="c1"># Tolles-Lawson coefficients (1D array)</span>
    <span class="n">terms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;permanent&#39;</span><span class="p">,</span> <span class="s1">&#39;induced&#39;</span><span class="p">,</span> <span class="s1">&#39;eddy&#39;</span><span class="p">],</span> <span class="c1"># Or use symbols/enums</span>
    <span class="n">Bt_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50000.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span> <span class="c1"># Returns (TL_aircraft_vector_field_3xN, B_earth_vector_field_3xN)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal helper to get imputed Earth vector and TL aircraft field.</span>
<span class="sd">    Corresponds to calculate_imputed_TL_earth in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get IGRF vector in body frame for the selected indices</span>
    <span class="c1"># get_igrf_magnetic_field from analysis_util</span>
    <span class="n">igrf_vector_body</span> <span class="o">=</span> <span class="n">get_igrf_magnetic_field</span><span class="p">(</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="n">norm_igrf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_xyz</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">set_igrf_in_xyz</span><span class="p">)</span>
    <span class="p">)</span> <span class="c1"># Returns 3xN_ind</span>

    <span class="k">if</span> <span class="n">set_igrf_in_xyz</span><span class="p">:</span>
        <span class="c1"># Calculate scalar IGRF and update in xyz object for the given indices</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">igrf</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">igrf_vector_body</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Total Earth field scalar magnitude (map anomaly + IGRF scalar)</span>
    <span class="c1"># Assuming map_val_scalar corresponds to ind</span>
    <span class="n">B_earth_scalar_total</span> <span class="o">=</span> <span class="n">map_val_scalar</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">igrf_vector_body</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># No diurnal here</span>

    <span class="c1"># Impute Earth vector field by scaling normalized IGRF vector</span>
    <span class="c1"># Normalize each column of igrf_vector_body (3xN_ind)</span>
    <span class="n">norm_igrf_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">igrf_vector_body</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Avoid division by zero if norm is zero</span>
    <span class="n">norm_igrf_vec</span><span class="p">[</span><span class="n">norm_igrf_vec</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-9</span> <span class="c1"># Replace zero norms</span>
    <span class="n">unit_igrf_vector_body</span> <span class="o">=</span> <span class="n">igrf_vector_body</span> <span class="o">/</span> <span class="n">norm_igrf_vec</span>
    
    <span class="n">B_earth_vector_body</span> <span class="o">=</span> <span class="n">unit_igrf_vector_body</span> <span class="o">*</span> <span class="n">B_earth_scalar_total</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># 3xN_ind</span>

    <span class="c1"># Time-derivative of Earth vector field (in body frame)</span>
    <span class="c1"># fdm from analysis_util, applied row-wise to 3xN_ind array</span>
    <span class="c1"># Assuming fdm handles 2D arrays by operating on rows or needs a loop/map.</span>
    <span class="c1"># If fdm is 1D:</span>
    <span class="n">B_earth_dot_body</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
        <span class="n">fdm</span><span class="p">(</span><span class="n">B_earth_vector_body</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]),</span>
        <span class="n">fdm</span><span class="p">(</span><span class="n">B_earth_vector_body</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]),</span>
        <span class="n">fdm</span><span class="p">(</span><span class="n">B_earth_vector_body</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>
    <span class="p">])</span> <span class="c1"># Results in 3xN_ind</span>

    <span class="c1"># Convert TL coefficients to matrix form (permanent, induced, eddy matrices)</span>
    <span class="c1"># tolles_lawson_coeffs_to_matrix from analysis_util</span>
    <span class="n">TL_coef_p_mat</span><span class="p">,</span> <span class="n">TL_coef_i_mat</span><span class="p">,</span> <span class="n">TL_coef_e_mat</span> <span class="o">=</span> \
        <span class="n">tolles_lawson_coeffs_to_matrix</span><span class="p">(</span><span class="n">TL_coef</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">,</span> <span class="n">Bt_scale</span><span class="o">=</span><span class="n">Bt_scale</span><span class="p">)</span>

    <span class="c1"># Calculate aircraft&#39;s magnetic field vector due to Earth&#39;s field (TL effect)</span>
    <span class="c1"># get_tolles_lawson_aircraft_field_vector from analysis_util</span>
    <span class="n">TL_aircraft_vector_field</span> <span class="o">=</span> <span class="n">get_tolles_lawson_aircraft_field_vector</span><span class="p">(</span>
        <span class="n">B_earth_vector_body</span><span class="p">,</span> <span class="n">B_earth_dot_body</span><span class="p">,</span>
        <span class="n">TL_coef_p_mat</span><span class="p">,</span> <span class="n">TL_coef_i_mat</span><span class="p">,</span> <span class="n">TL_coef_e_mat</span>
    <span class="p">)</span> <span class="c1"># Returns 3xN_ind</span>
    
    <span class="k">return</span> <span class="n">TL_aircraft_vector_field</span><span class="p">,</span> <span class="n">B_earth_vector_body</span></div>



<div class="viewcode-block" id="create_informed_xyz">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.create_informed_xyz">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_informed_xyz</span><span class="p">(</span>
    <span class="n">xyz</span><span class="p">:</span> <span class="n">XYZ0</span><span class="p">,</span> <span class="c1"># Assuming XYZ0 or a compatible type</span>
    <span class="n">ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="c1"># Indices for the subset of data</span>
    <span class="n">mapS</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span>
    <span class="n">use_mag_field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="c1"># e.g., &quot;mag_1_uc&quot;</span>
    <span class="n">use_vec_field_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="c1"># e.g., &quot;flux_a&quot;</span>
    <span class="n">TL_coef</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="c1"># Tolles-Lawson coefficients (1D array)</span>
    <span class="n">terms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;permanent&#39;</span><span class="p">,</span> <span class="s1">&#39;induced&#39;</span><span class="p">,</span> <span class="s1">&#39;eddy&#39;</span><span class="p">],</span>
    <span class="n">disp_min_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">,</span> <span class="c1"># Min displacement in meters</span>
    <span class="n">disp_max_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">500.0</span><span class="p">,</span> <span class="c1"># Max displacement in meters</span>
    <span class="n">Bt_disp_nT</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>  <span class="c1"># Target total field displacement offset in nT</span>
    <span class="n">Bt_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50000.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XYZ0</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create knowledge-informed XYZ data by displacing trajectory and updating mag fields.</span>
<span class="sd">    Corresponds to create_informed_xyz in Julia.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Basic validation of terms (simplified from Julia&#39;s specific symbol checks)</span>
    <span class="n">required_term_categories</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;permanent&#39;</span><span class="p">,</span> <span class="s1">&#39;induced&#39;</span><span class="p">,</span> <span class="s1">&#39;eddy&#39;</span><span class="p">}</span>
    <span class="n">provided_term_categories</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span> <span class="c1"># crude check</span>
        <span class="k">if</span> <span class="s1">&#39;perm&#39;</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span> <span class="n">provided_term_categories</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;permanent&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;ind&#39;</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span> <span class="n">provided_term_categories</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;induced&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;eddy&#39;</span> <span class="ow">in</span> <span class="n">term</span><span class="p">:</span> <span class="n">provided_term_categories</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;eddy&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">required_term_categories</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">provided_term_categories</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Permanent, induced, and eddy terms are required for create_informed_xyz.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fdm&#39;</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">]):</span> <span class="c1"># crude check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Derivative and bias terms may not be used in create_informed_xyz.&quot;</span><span class="p">)</span>

    <span class="c1"># Validate TL_coef length against a test A matrix (if create_TL_A is robust)</span>
    <span class="c1"># A_test = create_tolles_lawson_A_matrix(np.array([1.0]),np.array([1.0]),np.array([1.0]), terms=terms)</span>
    <span class="c1"># if len(TL_coef) != A_test.shape[1]:</span>
    <span class="c1">#     raise ValueError(&quot;TL_coef length does not agree with specified terms.&quot;)</span>

    <span class="c1"># Get the relevant subset of the trajectory</span>
    <span class="c1"># get_trajectory_subset from analysis_util</span>
    <span class="n">traj_subset</span> <span class="o">=</span> <span class="n">get_trajectory_subset</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">map_check</span><span class="p">(</span><span class="n">mapS</span><span class="p">,</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Original trajectory subset must be inside the provided map.&quot;</span><span class="p">)</span>

    <span class="c1"># Get scalar map values and interpolation object for the original trajectory subset</span>
    <span class="c1"># get_map_value_at_coords from analysis_util</span>
    <span class="n">map_val_orig</span><span class="p">,</span> <span class="n">itp_mapS_obj</span> <span class="o">=</span> <span class="n">get_map_val</span><span class="p">(</span>
        <span class="n">mapS</span><span class="p">,</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">traj_subset</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span>
        <span class="n">return_interpolator</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">itp_mapS_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not get map interpolator object.&quot;</span><span class="p">)</span>

    <span class="c1"># Calculate initial aircraft and Earth vector fields for the original subset</span>
    <span class="c1"># Note: set_igrf_in_xyz=False as we are not modifying the input xyz here.</span>
    <span class="n">TL_aircraft_orig</span><span class="p">,</span> <span class="n">B_earth_orig</span> <span class="o">=</span> <span class="n">calculate_imputed_TL_earth</span><span class="p">(</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">map_val_orig</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">TL_coef</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">,</span> <span class="n">Bt_scale</span><span class="o">=</span><span class="n">Bt_scale</span>
    <span class="p">)</span> <span class="c1"># Both are 3xN_ind</span>

    <span class="c1"># Determine displacement direction (towards map center, along map gradient)</span>
    <span class="c1"># Sample ~100 points along trajectory subset</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">))</span>
    <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">sampled_lats</span> <span class="o">=</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span>
    <span class="n">sampled_lons</span> <span class="o">=</span> <span class="n">traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span>

    <span class="c1"># Average lat/lon of trajectory subset and map center</span>
    <span class="n">traj_avg_latlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">)])</span>
    <span class="n">map_center_latlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">yy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mapS</span><span class="o">.</span><span class="n">xx</span><span class="p">)])</span> <span class="c1"># Assuming yy,xx are rad</span>

    <span class="c1"># Calculate average map gradient at sampled points</span>
    <span class="c1"># approximate_gradient(itp_func, y, x) from analysis_util -&gt; returns [dval/dlat, dval/dlon]</span>
    <span class="n">gradients_at_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">approximate_gradient</span><span class="p">(</span><span class="n">itp_mapS_obj</span><span class="p">,</span> <span class="n">la</span><span class="p">,</span> <span class="n">lo</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">la</span><span class="p">,</span> <span class="n">lo</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sampled_lats</span><span class="p">,</span> <span class="n">sampled_lons</span><span class="p">)]</span>
    <span class="n">avg_gradient_latlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gradients_at_samples</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># [avg_dval/dlat, avg_dval/dlon]</span>

    <span class="c1"># Displacement direction based on gradient, normalized</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">avg_gradient_latlon</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span> <span class="c1"># Avoid division by zero if gradient is flat</span>
        <span class="c1"># Default to direction towards map center if gradient is zero</span>
        <span class="n">disp_dir_latlon</span> <span class="o">=</span> <span class="n">map_center_latlon</span> <span class="o">-</span> <span class="n">traj_avg_latlon</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">disp_dir_latlon</span> <span class="o">=</span> <span class="n">avg_gradient_latlon</span>
    
    <span class="n">norm_disp_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">disp_dir_latlon</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_disp_dir</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span> <span class="c1"># If direction is still zero (e.g. traj_avg == map_center)</span>
        <span class="n">disp_dir_latlon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span> <span class="c1"># Arbitrary direction (e.g., East)</span>
        <span class="n">norm_disp_dir</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">disp_dir_unit_latlon</span> <span class="o">=</span> <span class="n">disp_dir_latlon</span> <span class="o">/</span> <span class="n">norm_disp_dir</span>

    <span class="c1"># Ensure displacement is towards map center (if gradient pointed away)</span>
    <span class="n">vec_to_map_center</span> <span class="o">=</span> <span class="n">map_center_latlon</span> <span class="o">-</span> <span class="n">traj_avg_latlon</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec_to_map_center</span><span class="p">,</span> <span class="n">disp_dir_unit_latlon</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">disp_dir_unit_latlon</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># Reverse direction</span>

    <span class="c1"># Convert displacement limits from meters to radians</span>
    <span class="c1"># Using dn2dlat, de2dlon from analysis_util</span>
    <span class="c1"># Use average latitude of the trajectory for conversion factor</span>
    <span class="n">avg_lat_for_conv</span> <span class="o">=</span> <span class="n">traj_avg_latlon</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">disp_min_rad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dn2dlat</span><span class="p">(</span><span class="n">disp_min_m</span><span class="p">,</span> <span class="n">avg_lat_for_conv</span><span class="p">),</span>
                       <span class="n">de2dlon</span><span class="p">(</span><span class="n">disp_min_m</span><span class="p">,</span> <span class="n">avg_lat_for_conv</span><span class="p">))</span>
    <span class="n">disp_max_rad</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dn2dlat</span><span class="p">(</span><span class="n">disp_max_m</span><span class="p">,</span> <span class="n">avg_lat_for_conv</span><span class="p">),</span>
                       <span class="n">de2dlon</span><span class="p">(</span><span class="n">disp_max_m</span><span class="p">,</span> <span class="n">avg_lat_for_conv</span><span class="p">))</span>

    <span class="c1"># Determine displacement magnitude in radians to achieve Bt_disp_nT change</span>
    <span class="c1"># Gradient magnitude along displacement direction: |d(MapVal)/d(Path)| in [nT/rad]</span>
    <span class="c1"># This is dot(avg_gradient_latlon, disp_dir_unit_latlon)</span>
    <span class="n">gradient_mag_along_disp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">avg_gradient_latlon</span><span class="p">,</span> <span class="n">disp_dir_unit_latlon</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">gradient_mag_along_disp</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span> <span class="c1"># Avoid division by zero if map is flat along displacement</span>
        <span class="n">disp_rad_magnitude</span> <span class="o">=</span> <span class="p">(</span><span class="n">disp_min_rad</span> <span class="o">+</span> <span class="n">disp_max_rad</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># Mid-range displacement</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">disp_rad_magnitude</span> <span class="o">=</span> <span class="n">Bt_disp_nT</span> <span class="o">/</span> <span class="n">gradient_mag_along_disp</span>
        
    <span class="c1"># Clamp displacement magnitude to [disp_min_rad, disp_max_rad]</span>
    <span class="n">disp_rad_magnitude_clamped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">disp_rad_magnitude</span><span class="p">,</span> <span class="n">disp_min_rad</span><span class="p">,</span> <span class="n">disp_max_rad</span><span class="p">)</span>
    
    <span class="c1"># Final displacement vector in (delta_lat_rad, delta_lon_rad)</span>
    <span class="n">displacement_latlon_rad</span> <span class="o">=</span> <span class="n">disp_rad_magnitude_clamped</span> <span class="o">*</span> <span class="n">disp_dir_unit_latlon</span>

    <span class="c1"># Create a deep copy of the original xyz data to modify</span>
    <span class="n">xyz_disp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

    <span class="c1"># Apply displacement to the trajectory subset in the new xyz_disp object</span>
    <span class="n">xyz_disp</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">displacement_latlon_rad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xyz_disp</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">displacement_latlon_rad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># Note: Velocities, accelerations, Cnb in xyz_disp.traj for these &#39;ind&#39; are NOT updated.</span>
    <span class="c1"># This assumes the displacement is a parallel shift and dynamics are preserved,</span>
    <span class="c1"># which is a simplification. Julia code also does not update them.</span>

    <span class="c1"># Check if new displaced trajectory is still on the map</span>
    <span class="n">displaced_traj_subset</span> <span class="o">=</span> <span class="n">get_trajectory_subset</span><span class="p">(</span><span class="n">xyz_disp</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">map_check</span><span class="p">(</span><span class="n">mapS</span><span class="p">,</span> <span class="n">displaced_traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">displaced_traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Displaced trajectory is outside the map. Adjust displacement parameters or map.&quot;</span><span class="p">)</span>

    <span class="c1"># Get scalar map values for the new displaced trajectory subset</span>
    <span class="n">map_val_disp</span> <span class="o">=</span> <span class="n">get_map_value_at_coords</span><span class="p">(</span>
        <span class="n">mapS</span><span class="p">,</span> <span class="n">displaced_traj_subset</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">displaced_traj_subset</span><span class="o">.</span><span class="n">lon</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">displaced_traj_subset</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">200</span>
    <span class="p">)</span>

    <span class="c1"># Calculate aircraft and Earth vector fields for the new displaced subset</span>
    <span class="c1"># This time, set_igrf_in_xyz=True to update IGRF in xyz_disp for these &#39;ind&#39;.</span>
    <span class="n">TL_aircraft_disp</span><span class="p">,</span> <span class="n">B_earth_disp</span> <span class="o">=</span> <span class="n">calculate_imputed_TL_earth</span><span class="p">(</span>
        <span class="n">xyz_disp</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">map_val_disp</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">TL_coef</span><span class="p">,</span> <span class="n">terms</span><span class="o">=</span><span class="n">terms</span><span class="p">,</span> <span class="n">Bt_scale</span><span class="o">=</span><span class="n">Bt_scale</span>
    <span class="p">)</span> <span class="c1"># Both are 3xN_ind</span>

    <span class="c1"># Calculate changes in vector fields</span>
    <span class="n">delta_B_TL_effect</span> <span class="o">=</span> <span class="n">TL_aircraft_disp</span> <span class="o">-</span> <span class="n">TL_aircraft_orig</span> <span class="c1"># Change due to aircraft&#39;s TL interaction at new spot</span>
    <span class="n">delta_B_earth_field</span> <span class="o">=</span> <span class="n">B_earth_disp</span> <span class="o">-</span> <span class="n">B_earth_orig</span>     <span class="c1"># Change due to Earth&#39;s field at new spot</span>
    <span class="n">total_delta_B_vector</span> <span class="o">=</span> <span class="n">delta_B_TL_effect</span> <span class="o">+</span> <span class="n">delta_B_earth_field</span> <span class="c1"># Total change in 3D vector field (3xN_ind)</span>

    <span class="c1"># Update vector magnetometer readings in xyz_disp for the specified field and indices</span>
    <span class="c1"># getattr and setattr can be used for dynamic field names</span>
    <span class="n">flux_disp_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xyz_disp</span><span class="p">,</span> <span class="n">use_vec_field_name</span><span class="p">)</span> <span class="c1"># e.g., xyz_disp.flux_a</span>
    
    <span class="c1"># Assuming flux_disp_obj fields (x,y,z,t) are numpy arrays that can be indexed by &#39;ind&#39;</span>
    <span class="c1"># And that they are already copies from deepcopy(xyz)</span>
    <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>
    <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                                   <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                                   <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># setattr(xyz_disp, use_vec_field_name, flux_disp_obj) # Not needed if flux_disp_obj is mutable reference</span>

    <span class="c1"># Update scalar magnetometer readings in xyz_disp</span>
    <span class="c1"># Change in scalar reading is projection of total_delta_B_vector onto new total field direction</span>
    <span class="c1"># New total field direction is approximately direction of flux_disp_obj.x/y/z[ind]</span>
    
    <span class="c1"># Project total_delta_B_vector onto the direction of the new (displaced) flux vector</span>
    <span class="c1"># new_flux_vectors_at_ind = np.vstack((flux_disp_obj.x[ind], flux_disp_obj.y[ind], flux_disp_obj.z[ind])) # 3xN_ind</span>
    <span class="c1"># norm_new_flux = np.linalg.norm(new_flux_vectors_at_ind, axis=0, keepdims=True)</span>
    <span class="c1"># norm_new_flux[norm_new_flux == 0] = 1e-9</span>
    <span class="c1"># unit_new_flux_vectors = new_flux_vectors_at_ind / norm_new_flux</span>
    <span class="c1"># delta_B_scalar_projection = np.sum(total_delta_B_vector * unit_new_flux_vectors, axis=0) # Dot product per column</span>

    <span class="c1"># Julia&#39;s approach for scalar update:</span>
    <span class="c1"># ΔB_dot = dot.(eachcol(ΔB),[[x,y,z] for (x,y,z) in zip(flux.x[ind],flux.y[ind],flux.z[ind])]) ./ flux.t[ind]</span>
    <span class="c1"># This is projecting ΔB onto the *original* flux direction at displaced location (before ΔB is added to flux).</span>
    <span class="c1"># Let&#39;s use the new flux vector (after adding total_delta_B_vector) for projection, which seems more consistent.</span>
    <span class="c1"># If flux.x[ind] etc. are already updated:</span>
    <span class="n">current_flux_x_at_ind</span> <span class="o">=</span> <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">current_flux_y_at_ind</span> <span class="o">=</span> <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">current_flux_z_at_ind</span> <span class="o">=</span> <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">current_flux_t_at_ind</span> <span class="o">=</span> <span class="n">flux_disp_obj</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="c1"># This is already sqrt(x^2+y^2+z^2) of *new* flux</span>

    <span class="c1"># Avoid division by zero for flux_t</span>
    <span class="n">valid_t_mask</span> <span class="o">=</span> <span class="n">current_flux_t_at_ind</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">delta_B_scalar_projection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">current_flux_t_at_ind</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_t_mask</span><span class="p">):</span>
        <span class="n">dot_prod_valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">current_flux_x_at_ind</span><span class="p">[</span><span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">current_flux_y_at_ind</span><span class="p">[</span><span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">total_delta_B_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">current_flux_z_at_ind</span><span class="p">[</span><span class="n">valid_t_mask</span><span class="p">])</span>
        <span class="n">delta_B_scalar_projection</span><span class="p">[</span><span class="n">valid_t_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot_prod_valid</span> <span class="o">/</span> <span class="n">current_flux_t_at_ind</span><span class="p">[</span><span class="n">valid_t_mask</span><span class="p">]</span>


    <span class="c1"># Update the specified uncompensated scalar magnetometer field</span>
    <span class="n">current_mag_uc_vals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xyz_disp</span><span class="p">,</span> <span class="n">use_mag_field_name</span><span class="p">)</span>
    <span class="n">current_mag_uc_vals</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta_B_scalar_projection</span>
    <span class="c1"># setattr(xyz_disp, use_mag_field_name, current_mag_uc_vals) # Not needed if mutable</span>

    <span class="c1"># Update the compensated scalar magnetometer field (mag_1_c)</span>
    <span class="c1"># Change is simply the difference in map anomaly values</span>
    <span class="n">delta_map_val_scalar</span> <span class="o">=</span> <span class="n">map_val_disp</span> <span class="o">-</span> <span class="n">map_val_orig</span>
    <span class="n">xyz_disp</span><span class="o">.</span><span class="n">mag_1_c</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta_map_val_scalar</span>
    
    <span class="k">return</span> <span class="n">xyz_disp</span></div>

<div class="viewcode-block" id="get_xyz20">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_xyz20">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_xyz20</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Placeholder for get_xyz20.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get_xyz20 is not yet implemented.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_XYZ">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.get_XYZ">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_XYZ</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Placeholder for get_XYZ.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get_XYZ is not yet implemented.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="sgl_2020_train">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.sgl_2020_train">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sgl_2020_train</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Placeholder for sgl_2020_train.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sgl_2020_train is not yet implemented.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="sgl_2021_train">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.create_xyz.sgl_2021_train">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sgl_2021_train</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Placeholder for sgl_2021_train.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sgl_2021_train is not yet implemented.&quot;</span><span class="p">)</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">MagNavPy</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Flight Path &amp; INS Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maps.html">Magnetic Anomaly Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../comp.html">Aeromagnetic Compensation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nncomp.html">Neural Network-Based Model Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nav.html">Navigation Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_functions.html">API: Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_structs.html">API: Structs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, MagNav.jl Authors & AI Porting Team.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>