<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>magnavpy.map_utils &#8212; MagNavPy 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=73454398" />
    <script src="../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">MagNavPy</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=manasp21&repo=magnav.py&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Flight Path &amp; INS Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maps.html">Magnetic Anomaly Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../comp.html">Aeromagnetic Compensation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nncomp.html">Neural Network-Based Model Diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../nav.html">Navigation Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../status.html">Current Status and Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_functions.html">API: Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_structs.html">API: Structs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for magnavpy.map_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions for map handling, including interpolation, trimming, filling,</span>
<span class="sd">and other manipulations.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.io</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">RegularGridInterpolator</span><span class="p">,</span> <span class="n">interpn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">KDTree</span> <span class="k">as</span> <span class="n">SciPyKDTree</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span> <span class="c1"># Used for dataclasses.replace</span>

<span class="c1"># Attempt to import MapS, MapV, MAP_S_NULL from .common_types</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.common_types</span><span class="w"> </span><span class="kn">import</span> <span class="n">MapS</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MAP_S_NULL</span><span class="p">,</span> <span class="n">MapCache</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Could not import types from .common_types in map_utils.py. Using placeholder types.&quot;</span><span class="p">)</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapS</span><span class="p">:</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;placeholder&quot;</span>
        <span class="n">lat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Meshgrid lat</span>
        <span class="n">lon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Meshgrid lon</span>
        <span class="n">alt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="nb">map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Unique lon coords</span>
        <span class="n">yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Unique lat coords</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapV</span><span class="p">:</span> <span class="c1"># Placeholder for vector map</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;placeholder&quot;</span>
        <span class="n">lat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">lon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">alt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">mapX</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">mapY</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">mapZ</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapS3D</span><span class="p">:</span> <span class="c1"># Placeholder for 3D scalar map</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;placeholder&quot;</span>
        <span class="n">lat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Meshgrid lat</span>
        <span class="n">lon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Meshgrid lon</span>
        <span class="n">alt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Array of altitudes</span>
        <span class="nb">map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># 3D: (yy, xx, alt_levels)</span>
        <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Unique lon coords</span>
        <span class="n">yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># Unique lat coords</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># 3D mask</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapSd</span><span class="p">:</span> <span class="c1"># Placeholder for drape scalar map</span>
        <span class="n">info</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;placeholder&quot;</span>
        <span class="n">lat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">lon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">alt</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span> <span class="c1"># 2D altitude grid</span>
        <span class="nb">map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]))</span>

    <span class="n">MAP_S_NULL</span> <span class="o">=</span> <span class="n">MapS</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="s2">&quot;null_map_placeholder&quot;</span><span class="p">)</span>

    <span class="nd">@dataclass</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">MapCacheBase</span><span class="p">:</span> <span class="c1"># Renamed to avoid conflict if common_types.MapCache exists</span>
        <span class="n">maps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MapS</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">fallback_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapS</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">dz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="c1"># Default altitude spacing for cache layers if generated</span>
        <span class="c1"># Store interpolators directly, keyed by a map identifier or altitude</span>
        <span class="n">_interpolators</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">_fallback_interpolator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_interpolators</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">add_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_obj</span><span class="p">:</span> <span class="n">MapS</span><span class="p">,</span> <span class="n">make_interpolator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">make_interpolator</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Key by map info and altitude for uniqueness</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interpolators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create interpolator for map </span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># TODO: Add logic for sorting maps by altitude if needed (like map_sort_ind in Julia)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">update_interpolators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interpolators</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">map_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interpolators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create interpolator for map </span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2"> during update: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fallback_map</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_interpolator</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fallback_map</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create interpolator for fallback map </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fallback_map</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_interpolator</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">def</span><span class="w"> </span><span class="nf">get_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alt_query</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Selects the best interpolator based on altitude.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolators</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_interpolator</span>

            <span class="n">best_interp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">min_alt_diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">map_info</span><span class="p">,</span> <span class="n">map_alt_scalar</span><span class="p">),</span> <span class="n">interp_func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">alt_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">map_alt_scalar</span> <span class="o">-</span> <span class="n">alt_query</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">alt_diff</span> <span class="o">&lt;</span> <span class="n">min_alt_diff</span><span class="p">:</span>
                    <span class="n">min_alt_diff</span> <span class="o">=</span> <span class="n">alt_diff</span>
                    <span class="n">best_interp</span> <span class="o">=</span> <span class="n">interp_func</span>
            
            <span class="k">if</span> <span class="n">best_interp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># No suitable primary map, use fallback</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fallback_interpolator</span>
            <span class="k">return</span> <span class="n">best_interp</span>

<span class="c1"># Helper functions (ported from Julia or new)</span>
<div class="viewcode-block" id="get_step">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.get_step">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_step</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the median step size (spacing) of elements in a 1D array.</span>
<span class="sd">    Returns 0.0 if array has fewer than 2 elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arr</span><span class="p">))))</span></div>


<div class="viewcode-block" id="map_params">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_params">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_params</span><span class="p">(</span><span class="n">map_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">map_xx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">map_yy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get basic map parameters: zero/non-zero indices and dimensions.</span>
<span class="sd">    Assumes map_data is 2D. Zeros and NaNs are treated as invalid/gap data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    
    <span class="n">map_copy</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Avoid modifying original</span>
    <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map_copy</span><span class="p">)</span>
    <span class="n">map_copy</span><span class="p">[</span><span class="n">nan_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Replace NaNs with 0 for consistent gap identification</span>

    <span class="n">ind0</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_copy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Indices of gaps (originally zero or NaN)</span>
    <span class="n">ind1</span> <span class="o">=</span> <span class="o">~</span><span class="n">ind0</span>           <span class="c1"># Indices of valid data</span>

    <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="k">if</span> <span class="n">map_xx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nx</span> <span class="o">!=</span> <span class="n">map_xx</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;xx map dimension (</span><span class="si">{</span><span class="n">map_xx</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">) inconsistent with map_data x-dim (</span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">map_yy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ny</span> <span class="o">!=</span> <span class="n">map_yy</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;yy map dimension (</span><span class="si">{</span><span class="n">map_yy</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">) inconsistent with map_data y-dim (</span><span class="si">{</span><span class="n">ny</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            
    <span class="c1"># Ensure a 4-tuple is always returned</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">ny</span><span class="p">))</span></div>


<div class="viewcode-block" id="map_lims">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_lims">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_lims</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">],</span> <span class="n">buffer_percent</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the latitude and longitude limits of a map object with an optional buffer.</span>
<span class="sd">    Returns ((lat_min, lat_max), (lon_min, lon_max)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span>
    <span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">buffer_percent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lon_range</span> <span class="o">=</span> <span class="n">lon_max</span> <span class="o">-</span> <span class="n">lon_min</span>
        <span class="n">lat_range</span> <span class="o">=</span> <span class="n">lat_max</span> <span class="o">-</span> <span class="n">lat_min</span>
        <span class="n">lon_buffer</span> <span class="o">=</span> <span class="n">lon_range</span> <span class="o">*</span> <span class="n">buffer_percent</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="n">lat_buffer</span> <span class="o">=</span> <span class="n">lat_range</span> <span class="o">*</span> <span class="n">buffer_percent</span> <span class="o">/</span> <span class="mf">100.0</span>
        <span class="n">lon_min</span> <span class="o">-=</span> <span class="n">lon_buffer</span>
        <span class="n">lon_max</span> <span class="o">+=</span> <span class="n">lon_buffer</span>
        <span class="n">lat_min</span> <span class="o">-=</span> <span class="n">lat_buffer</span>
        <span class="n">lat_max</span> <span class="o">+=</span> <span class="n">lat_buffer</span>
        
    <span class="k">return</span> <span class="p">(</span><span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">),</span> <span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">)</span></div>


<div class="viewcode-block" id="map_res">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_res">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_res</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the approximate median resolution (dy, dx) of the map in the units of yy, xx.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Allow single point maps</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># For single point maps, resolution is undefined, return 0</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">get_step</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span> <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">get_step</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">)</span> <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span></div>


<div class="viewcode-block" id="map_shape">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_shape">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_shape</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the shape of the primary map data.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;mapX&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># For MapV</span>
        <span class="k">return</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<span class="c1"># Core map functions</span>
<div class="viewcode-block" id="map_interpolate">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.map_interpolate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_interpolate</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span>
                    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="n">return_vert_deriv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates and returns an interpolator function for a MapS or MapS3D object.</span>
<span class="sd">    For MapS3D, interpolates through the altitude dimension as well if alt_query is provided to the interpolator.</span>

<span class="sd">    Args:</span>
<span class="sd">        map_obj: MapS or MapS3D object.</span>
<span class="sd">        method: Interpolation method (&quot;linear&quot;, &quot;nearest&quot;). &quot;cubic&quot; requires interpn.</span>
<span class="sd">        bounds_error: If True, raise error for out-of-bounds. Else, use fill_value.</span>
<span class="sd">        fill_value: Value for out-of-bounds points.</span>

<span class="sd">    Returns:</span>
<span class="sd">        If return_vert_deriv is False:</span>
<span class="sd">            A callable interpolator function, or None if interpolation setup fails.</span>
<span class="sd">            The interpolator expects points as (lat, lon) for MapS, or (lat, lon, alt) for MapS3D.</span>
<span class="sd">        If return_vert_deriv is True:</span>
<span class="sd">            A tuple (interpolator, derivative_interpolator).</span>
<span class="sd">            Currently, derivative_interpolator will be None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_ERROR_6: map_interpolate from map_utils.py called. map_obj type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span><span class="si">}</span><span class="s2">, return_vert_deriv: </span><span class="si">{</span><span class="n">return_vert_deriv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># For Error 6</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;yy&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;xx&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Map object is missing &#39;yy&#39;, &#39;xx&#39;, or &#39;map&#39; attributes.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Map &#39;</span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&#39; has None for map, yy, or xx. Cannot create interpolator.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_vert_deriv</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">map_grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">map_grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">map_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">map_grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">map_grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_grid_lon</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">map_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Map &#39;</span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&#39; has empty coordinates or map data. Cannot create interpolator.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_vert_deriv</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Map grid coordinates (yy, xx) must be 1D for RegularGridInterpolator.&quot;</span><span class="p">)</span>

    <span class="n">points_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;alt&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MapS3D object must have &#39;alt&#39; coordinates for 3D interpolation.&quot;</span><span class="p">)</span>
        <span class="n">map_grid_alt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">map_grid_alt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">map_grid_alt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_grid_alt</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">map_grid_alt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MapS3D.alt coordinates must be 1D for RegularGridInterpolator.&quot;</span><span class="p">)</span>
        <span class="n">points_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="p">,</span> <span class="n">map_grid_alt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">map_values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">map_values</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">map_grid_alt</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MapS3D data shape </span><span class="si">{</span><span class="n">map_values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> mismatch with grid dimensions.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">map_values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">map_values</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MapS data shape </span><span class="si">{</span><span class="n">map_values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> mismatch with grid dimensions.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;map_obj must be MapS or MapS3D.&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cubic&quot;</span> <span class="ow">and</span> <span class="n">map_values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">:</span> <span class="c1"># interpn supports cubic for &gt;1D</span>
             <span class="c1"># For interpn, points are (coords_dim1, coords_dim2, ...)</span>
             <span class="c1"># and xi is a tuple of new coordinate arrays or a (N, D_coord) array of points</span>
             <span class="c1"># To make it behave like RegularGridInterpolator, we wrap it.</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">interpn_callable</span><span class="p">(</span><span class="n">query_points_array</span><span class="p">):</span>
                <span class="c1"># query_points_array is (N, D_coord)</span>
                <span class="c1"># interpn expects xi as a tuple of arrays for each dimension if method is not &#39;linear&#39; or &#39;nearest&#39; for grid.</span>
                <span class="c1"># Or, if xi is (M, ndim), it&#39;s treated as M points.</span>
                <span class="k">return</span> <span class="n">interpn</span><span class="p">(</span><span class="n">points_coords</span><span class="p">,</span> <span class="n">map_values</span><span class="p">,</span> <span class="n">query_points_array</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">return_vert_deriv</span><span class="p">:</span>
                <span class="c1"># TODO: Implement actual vertical derivative calculation and its interpolator</span>
                <span class="k">return</span> <span class="n">interpn_callable</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">interpn_callable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span>
                <span class="n">points_coords</span><span class="p">,</span>
                <span class="n">map_values</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_vert_deriv</span><span class="p">:</span>
                <span class="c1"># TODO: Implement actual vertical derivative calculation and its interpolator</span>
                <span class="k">return</span> <span class="n">interpolator</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">interpolator</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error creating interpolator for map &#39;</span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Check if coordinates are sorted and unique.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_vert_deriv</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="get_map_val">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.get_map_val">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_map_val</span><span class="p">(</span>
    <span class="n">map_data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapCache</span><span class="p">],</span> <span class="c1"># Extended to MapS3D</span>
    <span class="n">lat_query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">lon_query</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">alt_query</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">bounds_error</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
    <span class="n">return_interpolator</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get magnetic anomaly map value(s) at specified geographic coordinate(s).</span>
<span class="sd">    Interpolates from MapS, MapS3D, or uses MapCacheBase.</span>
<span class="sd">    For MapS3D, alt_query is required for 3D interpolation.</span>
<span class="sd">    If MapS (2D) is given and alt_query is provided, it&#39;s currently ignored by the interpolator itself</span>
<span class="sd">    unless specific logic for upward/downward continuation is added here (complex).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interpolator_object</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="n">MapCache</span><span class="p">):</span>
        <span class="c1"># Determine query altitude for cache selection</span>
        <span class="n">alt_q_scalar</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># Default</span>
        <span class="k">if</span> <span class="n">alt_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alt_q_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">alt_query</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_query</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">alt_query</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">map_data</span><span class="o">.</span><span class="n">maps</span><span class="p">:</span> <span class="c1"># Use first map&#39;s altitude from cache if alt_query is None</span>
            <span class="n">first_map_alt</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">alt</span>
            <span class="n">alt_q_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">first_map_alt</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_map_alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">first_map_alt</span><span class="p">)</span>
        
        <span class="n">interpolator_object</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">.</span><span class="n">get_interpolator</span><span class="p">(</span><span class="n">alt_q_scalar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interpolator_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># print(&quot;Warning: No suitable interpolator in MapCache. Returning NaNs.&quot;)</span>
            <span class="n">nan_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat_query</span><span class="p">),</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nan_vals</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_interpolator</span> <span class="k">else</span> <span class="n">nan_vals</span>
    
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="p">(</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)):</span>
        <span class="n">interpolator_object</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">interpolator_object</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Interpolator creation failed</span>
            <span class="n">nan_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat_query</span><span class="p">),</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nan_vals</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_interpolator</span> <span class="k">else</span> <span class="n">nan_vals</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="n">MapV</span><span class="p">):</span>
        <span class="c1"># Check for essential attributes and non-None map components</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="s1">&#39;yy&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="s1">&#39;xx&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">map_data</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_data</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">map_data</span><span class="o">.</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_data</span><span class="o">.</span><span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_data</span><span class="o">.</span><span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># print(f&quot;Warning: MapV &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39; is missing attributes or has None for coordinates/component maps. Cannot interpolate.&quot;)</span>
            <span class="c1"># Determine shape for NaN values based on original inputs</span>
            <span class="n">original_input_shape_for_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="n">lon_query</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original_input_shape_for_nans</span><span class="p">:</span> <span class="c1"># scalar inputs</span>
                <span class="n">nan_val_to_use</span> <span class="o">=</span> <span class="n">fill_value</span> <span class="c1"># Already a float</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># array inputs</span>
                <span class="n">nan_val_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">original_input_shape_for_nans</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

            <span class="n">nan_result_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_val_to_use</span><span class="p">,</span> <span class="n">nan_val_to_use</span><span class="p">,</span> <span class="n">nan_val_to_use</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nan_result_tuple</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="k">if</span> <span class="n">return_interpolator</span> <span class="k">else</span> <span class="n">nan_result_tuple</span>

        <span class="n">map_grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_data</span><span class="o">.</span><span class="n">yy</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">map_grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">map_data</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">map_grid_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
        <span class="k">if</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">map_grid_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_grid_lon</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>

        <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># print(f&quot;Warning: MapV &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39; has empty coordinates. Cannot interpolate.&quot;)</span>
            <span class="n">original_input_shape_for_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="n">lon_query</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original_input_shape_for_nans</span><span class="p">:</span> <span class="c1"># scalar inputs</span>
                <span class="n">nan_val_to_use</span> <span class="o">=</span> <span class="n">fill_value</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># array inputs</span>
                <span class="n">nan_val_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">original_input_shape_for_nans</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">nan_result_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">nan_val_to_use</span><span class="p">,</span> <span class="n">nan_val_to_use</span><span class="p">,</span> <span class="n">nan_val_to_use</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">nan_result_tuple</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="k">if</span> <span class="n">return_interpolator</span> <span class="k">else</span> <span class="n">nan_result_tuple</span>

        <span class="k">if</span> <span class="n">map_grid_lat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MapV grid coordinates (yy, xx) must be 1D.&quot;</span><span class="p">)</span>

        <span class="n">points_coords_2d</span> <span class="o">=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="p">)</span>

        <span class="c1"># Prepare query points, ensuring they can be broadcasted or match</span>
        <span class="n">lat_q_arr_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat_query</span><span class="p">)</span> <span class="c1"># Keep original for broadcast shape determination</span>
        <span class="n">lon_q_arr_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lon_query</span><span class="p">)</span>

        <span class="c1"># Attempt to broadcast query points for processing</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lat_q_arr_orig</span><span class="p">,</span> <span class="n">lon_q_arr_orig</span><span class="p">)</span>
            <span class="c1"># Create query arrays based on the broadcast output shape</span>
            <span class="c1"># This ensures lat_q_arr and lon_q_arr are compatible for column_stack</span>
            <span class="c1"># and correctly represent the query points over the broadcasted grid.</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="c1"># If broadcast result is not scalar</span>
                <span class="n">query_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
                <span class="n">query_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lat_q_arr_orig</span> <span class="c1"># Broadcasting happens here</span>
                <span class="n">query_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lon_q_arr_orig</span> <span class="c1"># And here</span>
                <span class="n">lat_q_arr</span> <span class="o">=</span> <span class="n">query_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">lon_q_arr</span> <span class="o">=</span> <span class="n">query_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Scalar broadcast</span>
                <span class="n">lat_q_arr</span> <span class="o">=</span> <span class="n">lat_q_arr_orig</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">lon_q_arr</span> <span class="o">=</span> <span class="n">lon_q_arr_orig</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># If broadcasting fails</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat_query, lon_query shapes are incompatible for MapV interpolation.&quot;</span><span class="p">)</span>


        <span class="n">query_points_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">lat_q_arr</span><span class="p">,</span> <span class="n">lon_q_arr</span><span class="p">))</span>
        <span class="n">original_input_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="n">lon_query</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Shape of the final output</span>

        <span class="n">results_xyz_components</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interpolators_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">return_interpolator</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">component_idx</span><span class="p">,</span> <span class="n">component_data_array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">map_data</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">map_data</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">map_data</span><span class="o">.</span><span class="n">z</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">component_data_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">comp_name</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="n">component_idx</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;MapV component &#39;</span><span class="si">{</span><span class="n">comp_name</span><span class="si">}</span><span class="s2">&#39; data shape </span><span class="si">{</span><span class="n">component_data_array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> mismatch with grid dimensions &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">map_grid_lat</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">map_grid_lon</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">) for map &#39;</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;info&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;N/A&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            
            <span class="n">current_interpolator</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Ensure map grid coordinates are sorted for RegularGridInterpolator</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">map_grid_lat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">map_grid_lat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># Attempt to sort if not monotonic, this is a bit risky if map_data is not aligned</span>
                    <span class="c1"># print(f&quot;Warning: MapV latitude coordinates for map &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39; are not monotonic. Attempting to sort.&quot;)</span>
                    <span class="c1"># sort_idx_lat = np.argsort(map_grid_lat)</span>
                    <span class="c1"># map_grid_lat_sorted = map_grid_lat[sort_idx_lat]</span>
                    <span class="c1"># component_data_array_sorted_lat = component_data_array[sort_idx_lat, :]</span>
                    <span class="k">pass</span> <span class="c1"># For now, assume they should be sorted by the caller or map creation</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">map_grid_lon</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">map_grid_lon</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c1"># print(f&quot;Warning: MapV longitude coordinates for map &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39; are not monotonic. Attempting to sort.&quot;)</span>
                    <span class="c1"># sort_idx_lon = np.argsort(map_grid_lon)</span>
                    <span class="c1"># map_grid_lon_sorted = map_grid_lon[sort_idx_lon]</span>
                    <span class="c1"># component_data_array_final = (component_data_array_sorted_lat if &#39;component_data_array_sorted_lat&#39; in locals() else component_data_array)[:, sort_idx_lon]</span>
                    <span class="k">pass</span> <span class="c1"># For now, assume they should be sorted</span>

                <span class="n">interpolator_comp</span> <span class="o">=</span> <span class="n">RegularGridInterpolator</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">map_grid_lat</span><span class="p">,</span> <span class="n">map_grid_lon</span><span class="p">),</span> <span class="c1"># Use potentially sorted coords</span>
                    <span class="n">component_data_array</span><span class="p">,</span> <span class="c1"># Use potentially sorted data</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="n">bounds_error</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
                <span class="p">)</span>
                <span class="n">interpolated_values_comp_flat</span> <span class="o">=</span> <span class="n">interpolator_comp</span><span class="p">(</span><span class="n">query_points_2d</span><span class="p">)</span>
                <span class="n">current_interpolator</span> <span class="o">=</span> <span class="n">interpolator_comp</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ve</span><span class="p">:</span> <span class="c1"># Catch specific errors from RGI if coords not strictly monotonic</span>
                <span class="c1"># print(f&quot;ValueError during MapV component interpolation for map &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39;: {ve}. Check coordinate monotonicity.&quot;)</span>
                <span class="n">interpolated_values_comp_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">query_points_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># print(f&quot;Error during MapV component interpolation for map &#39;{getattr(map_data, &#39;info&#39;, &#39;N/A&#39;)}&#39;: {e}&quot;)</span>
                <span class="n">interpolated_values_comp_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">query_points_2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">return_interpolator</span> <span class="ow">and</span> <span class="n">interpolators_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">interpolators_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_interpolator</span><span class="p">)</span>

            <span class="c1"># Reshape component to match original query structure</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">original_input_shape</span><span class="p">:</span> <span class="c1"># All original inputs were scalar</span>
                <span class="n">reshaped_component_value</span> <span class="o">=</span> <span class="n">interpolated_values_comp_flat</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">interpolated_values_comp_flat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">interpolated_values_comp_flat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reshaped_component_value</span> <span class="o">=</span> <span class="n">interpolated_values_comp_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_input_shape</span><span class="p">)</span>
                <span class="c1"># Ensure scalar output for scalar inputs even if original_input_shape is e.g. (1,) but inputs were float</span>
                <span class="k">if</span> <span class="n">reshaped_component_value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> \
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> \
                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon_query</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span> <span class="c1"># Check original types</span>
                     <span class="n">reshaped_component_value</span> <span class="o">=</span> <span class="n">reshaped_component_value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">results_xyz_components</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reshaped_component_value</span><span class="p">)</span>

        <span class="n">final_tuple_result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">results_xyz_components</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_interpolator</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_tuple_result</span><span class="p">,</span> <span class="n">interpolators_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">final_tuple_result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;map_data must be a MapS, MapS3D, MapV, or MapCache object.&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare query points</span>
    <span class="n">lat_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lat_query</span><span class="p">)</span>
    <span class="n">lon_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">lon_query</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">map_data</span><span class="p">,</span> <span class="n">MapCache</span><span class="p">)</span> <span class="ow">and</span> <span class="n">alt_query</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">alt_query</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;alt_query must be provided for 3D interpolation with MapS3D or relevant MapCache.&quot;</span><span class="p">)</span>
        <span class="n">alt_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">alt_query</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
             <span class="c1"># If shapes differ, attempt to broadcast if one is scalar and others are arrays.</span>
             <span class="c1"># This case needs careful handling if general broadcasting is desired.</span>
             <span class="c1"># For now, assume they should match or be scalar.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                 <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat_query, lon_query, alt_query must have same shape for 3D interpolation or be scalar.&quot;</span><span class="p">)</span>
            <span class="c1"># Basic broadcasting for scalar + array</span>
            <span class="k">if</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">lat_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lon_q_arr</span><span class="p">,</span> <span class="n">lat_q_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">lon_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lat_q_arr</span><span class="p">,</span> <span class="n">lon_q_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">alt_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lat_q_arr</span><span class="p">,</span> <span class="n">alt_q_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Recheck after basic broadcasting attempt</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                 <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat_query, lon_query, alt_query shapes are incompatible after basic broadcasting.&quot;</span><span class="p">)</span>


        <span class="n">query_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">alt_q_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># 2D interpolation</span>
        <span class="k">if</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lat_query, lon_query must have same shape for 2D interpolation or be scalar.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">lat_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lon_q_arr</span><span class="p">,</span> <span class="n">lat_q_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lat_q_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">lon_q_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">lat_q_arr</span><span class="p">,</span> <span class="n">lon_q_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">query_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">lat_q_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">lon_q_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">interpolated_values</span> <span class="o">=</span> <span class="n">interpolator_object</span><span class="p">(</span><span class="n">query_points</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># print(f&quot;Error during interpolation: {e}&quot;)</span>
        <span class="c1"># This can happen if query points are outside strict bounds and bounds_error=True for RegularGridInterpolator</span>
        <span class="c1"># or other interpolator issues.</span>
        <span class="n">nan_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">query_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">interpolated_values</span> <span class="o">=</span> <span class="n">nan_vals</span>


    <span class="c1"># Reshape to match original query shape if input was array, otherwise squeeze to scalar</span>
    <span class="n">output_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="n">lon_query</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="c1"># Get shape from original inputs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">output_shape</span><span class="p">:</span> <span class="c1"># If all inputs were scalar</span>
        <span class="n">result_values</span> <span class="o">=</span> <span class="n">interpolated_values</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">interpolated_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">interpolated_values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result_values</span> <span class="o">=</span> <span class="n">interpolated_values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat_query</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span> <span class="c1"># Squeezed back if original was scalar-like</span>
             <span class="n">result_values</span> <span class="o">=</span> <span class="n">result_values</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>


    <span class="k">if</span> <span class="n">return_interpolator</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result_values</span><span class="p">,</span> <span class="n">interpolator_object</span>
    <span class="k">return</span> <span class="n">result_values</span></div>



<div class="viewcode-block" id="map_gradient">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_gradient">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_gradient</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span> <span class="n">on_interpolated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">query_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the gradient of the map.</span>
<span class="sd">    If on_interpolated is False (default), uses np.gradient on the raw map_obj.map data.</span>
<span class="sd">    Spacing is taken from map_obj.yy, map_obj.xx (and map_obj.alt for 3D).</span>
<span class="sd">    If on_interpolated is True, query_points must be provided, and the gradient of the</span>
<span class="sd">    interpolated field at these points is computed using finite differences. (This part is simplified).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">on_interpolated</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">):</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
        
        <span class="c1"># Check for uniform spacing, np.gradient prefers this or explicit coordinates</span>
        <span class="c1"># For simplicity, we pass the coordinate vectors directly if supported,</span>
        <span class="c1"># otherwise, user must be aware of scaling.</span>
        <span class="c1"># np.gradient accepts coordinate vectors from version 1.26</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span> <span class="c1"># Older NumPy might not support list of coordinates</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: np.gradient with coordinate vectors failed (likely older NumPy). Calculating unscaled gradient.&quot;</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>
            <span class="c1"># Manual scaling would be needed here:</span>
            <span class="c1"># dy = get_step(map_obj.yy); dx = get_step(map_obj.xx)</span>
            <span class="c1"># grad[0] /= dy; grad[1] /= dx</span>
            <span class="c1"># if isinstance(map_obj, MapS3D): d_alt = get_step(map_obj.alt); grad[2] /= d_alt</span>
        <span class="k">return</span> <span class="n">grad</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Gradient of interpolated field (simplified: user should do this carefully)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Placeholder: map_gradient on_interpolated=True. User should interpolate at query_points and neighbors, then apply finite differences.&quot;</span><span class="p">)</span>
        <span class="c1"># itp = map_interpolate(map_obj, method=method)</span>
        <span class="c1"># if itp is None or query_points is None: return None</span>
        <span class="c1"># ... logic to compute gradient at query_points using itp ...</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="map_hessian">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_hessian">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_hessian</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span> <span class="n">on_interpolated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Hessian matrix of the map. Placeholder.</span>
<span class="sd">    If on_interpolated is False, uses np.gradient twice on raw map_obj.map data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Placeholder: map_hessian called. Implement using np.gradient twice on map_obj.map or interpolated field.&quot;</span><span class="p">)</span>
    <span class="c1"># grad_list = map_gradient(map_obj, on_interpolated=on_interpolated, **kwargs)</span>
    <span class="c1"># if grad_list is None: return None</span>
    <span class="c1"># hessian_matrix = []</span>
    <span class="c1"># for grad_component in grad_list:</span>
    <span class="c1">#     # This needs careful handling of coordinates for np.gradient again</span>
    <span class="c1">#     coords = [map_obj.yy, map_obj.xx]</span>
    <span class="c1">#     if isinstance(map_obj, MapS3D): coords.append(map_obj.alt)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         hessian_row = np.gradient(grad_component, *coords)</span>
    <span class="c1">#     except TypeError:</span>
    <span class="c1">#         hessian_row = np.gradient(grad_component) # Unscaled</span>
    <span class="c1">#     hessian_matrix.append(hessian_row)</span>
    <span class="c1"># return hessian_matrix # This will be list of lists of arrays</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="map_trim">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_trim">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_trim</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapV</span><span class="p">],</span>
             <span class="n">lat_lim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">lon_lim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">alt_lim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># For MapS3D</span>
             <span class="n">pad_cells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
             <span class="n">trim_to_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
             <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapV</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trims a map object to specified latitude/longitude limits and/or to data bounds.</span>

<span class="sd">    Args:</span>
<span class="sd">        map_obj: The map object to trim.</span>
<span class="sd">        lat_lim: Optional (min_lat, max_lat) tuple.</span>
<span class="sd">        lon_lim: Optional (min_lon, max_lon) tuple.</span>
<span class="sd">        alt_lim: Optional (min_alt, max_alt) tuple (for MapS3D).</span>
<span class="sd">        pad_cells: Number of cells to pad around the data bounds if trim_to_data is True.</span>
<span class="sd">        trim_to_data: If True, also trim to the bounding box of non-gap data.</span>
<span class="sd">        copy: If True, returns a new trimmed map object. Otherwise, modifies in place if possible.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The trimmed map object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">map_obj</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="c1"># Create a new object with copied underlying arrays</span>
        <span class="n">map_obj</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span> <span class="c1"># Shallow copy of dataclass structure</span>
        <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="s1">&#39;xx&#39;</span><span class="p">,</span> <span class="s1">&#39;yy&#39;</span><span class="p">,</span> <span class="s1">&#39;alt&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="s1">&#39;mapX&#39;</span><span class="p">,</span> <span class="s1">&#39;mapY&#39;</span><span class="p">,</span> <span class="s1">&#39;mapZ&#39;</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    
    <span class="n">current_map_data</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span> <span class="c1"># Use mapX for MapV</span>

    <span class="c1"># Determine initial slicing from data presence if trim_to_data</span>
    <span class="n">min_r</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">min_c</span><span class="p">,</span> <span class="n">max_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_map_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_map_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">trim_to_data</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">valid_data_mask</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">map_params</span><span class="p">(</span><span class="n">current_map_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_data_mask</span><span class="p">):</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">valid_data_mask</span><span class="p">)</span>
            <span class="n">min_r_data</span><span class="p">,</span> <span class="n">max_r_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">min_c_data</span><span class="p">,</span> <span class="n">max_c_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="n">min_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_r</span><span class="p">,</span> <span class="n">min_r_data</span> <span class="o">-</span> <span class="n">pad_cells</span><span class="p">)</span>
            <span class="n">max_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_r</span><span class="p">,</span> <span class="n">max_r_data</span> <span class="o">+</span> <span class="n">pad_cells</span><span class="p">)</span>
            <span class="n">min_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_c</span><span class="p">,</span> <span class="n">min_c_data</span> <span class="o">-</span> <span class="n">pad_cells</span><span class="p">)</span>
            <span class="n">max_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_c</span><span class="p">,</span> <span class="n">max_c_data</span> <span class="o">+</span> <span class="n">pad_cells</span><span class="p">)</span>

    <span class="c1"># Apply lat/lon limits</span>
    <span class="k">if</span> <span class="n">lat_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">lat_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">))</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">lat_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">lon_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">lon_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">))</span>
        <span class="n">max_c</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">lon_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">))</span>

    <span class="c1"># Ensure slices are valid</span>
    <span class="n">min_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">min_r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">max_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_r</span><span class="p">,</span> <span class="n">min_r</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">min_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">min_c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">max_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_c</span><span class="p">,</span> <span class="n">min_c</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    
    <span class="n">yy_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">min_r</span><span class="p">,</span> <span class="n">max_r</span><span class="p">)</span>
    <span class="n">xx_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">min_c</span><span class="p">,</span> <span class="n">max_c</span><span class="p">)</span>

    <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">]</span>
    <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">[</span><span class="n">xx_slice</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
         <span class="n">map_obj</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
         <span class="n">map_obj</span><span class="o">.</span><span class="n">lon</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>

    <span class="n">alt_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="c1"># For 3rd dimension of MapS3D</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="ow">and</span> <span class="n">alt_lim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">alt_lim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="n">max_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">alt_lim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="n">min_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">min_a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">max_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">max_a</span><span class="p">,</span> <span class="n">min_a</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">alt_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">min_a</span><span class="p">,</span> <span class="n">max_a</span><span class="p">)</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">alt_slice</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">,</span> <span class="n">alt_slice</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="k">else</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">,</span> <span class="n">alt_slice</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span> <span class="k">else</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapV</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapX</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapY</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapY</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapY</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapZ</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mapZ</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="s1">&#39;alt&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">[</span><span class="n">yy_slice</span><span class="p">,</span> <span class="n">xx_slice</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">map_obj</span></div>



<div class="viewcode-block" id="map_fill_gaps">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_fill_gaps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_fill_gaps</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fills NaN or zero gaps in a map object using k-nearest neighbors.</span>
<span class="sd">    For MapS3D, fills slice by slice along the altitude dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">map_obj</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">map_obj</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">fill_2d_slice</span><span class="p">(</span><span class="n">data_slice</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">yy_coords_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xx_coords_vec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k_val</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_slice</span><span class="p">)</span>
        <span class="n">zero_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_slice</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Assuming 0 is also a gap</span>
        <span class="n">gap_mask</span> <span class="o">=</span> <span class="n">nan_mask</span> <span class="o">|</span> <span class="n">zero_mask</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gap_mask</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">data_slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data_slice</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="c1"># Return original mask if no gaps</span>

        <span class="n">yy_grid</span><span class="p">,</span> <span class="n">xx_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">yy_coords_vec</span><span class="p">,</span> <span class="n">xx_coords_vec</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        
        <span class="n">valid_points_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">gap_mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">valid_points_mask</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: No valid data points in slice for map_fill_gaps.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_slice</span><span class="p">,</span> <span class="n">gap_mask</span> <span class="c1"># Return original data and gap mask</span>

        <span class="n">valid_yy</span> <span class="o">=</span> <span class="n">yy_grid</span><span class="p">[</span><span class="n">valid_points_mask</span><span class="p">]</span>
        <span class="n">valid_xx</span> <span class="o">=</span> <span class="n">xx_grid</span><span class="p">[</span><span class="n">valid_points_mask</span><span class="p">]</span>
        <span class="n">valid_values</span> <span class="o">=</span> <span class="n">data_slice</span><span class="p">[</span><span class="n">valid_points_mask</span><span class="p">]</span>
        
        <span class="n">gap_yy</span> <span class="o">=</span> <span class="n">yy_grid</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span>
        <span class="n">gap_xx</span> <span class="o">=</span> <span class="n">xx_grid</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">gap_yy</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">data_slice</span><span class="p">,</span> <span class="o">~</span><span class="n">gap_mask</span> <span class="c1"># Should be caught by np.any(gap_mask)</span>

        <span class="n">tree_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">valid_yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">valid_xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">tree_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
             <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: No valid data points to build KDTree in slice.&quot;</span><span class="p">)</span>
             <span class="k">return</span> <span class="n">data_slice</span><span class="p">,</span> <span class="o">~</span><span class="n">gap_mask</span>

        <span class="n">kdtree</span> <span class="o">=</span> <span class="n">SciPyKDTree</span><span class="p">(</span><span class="n">tree_data</span><span class="p">)</span>
        <span class="n">query_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">gap_yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">gap_xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        
        <span class="n">actual_k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k_val</span><span class="p">,</span> <span class="n">tree_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">actual_k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">data_slice</span><span class="p">,</span> <span class="o">~</span><span class="n">gap_mask</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">kdtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query_points</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">actual_k</span><span class="p">)</span>
        
        <span class="n">filled_slice</span> <span class="o">=</span> <span class="n">data_slice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">actual_k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">filled_values</span> <span class="o">=</span> <span class="n">valid_values</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filled_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">valid_values</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="n">filled_slice</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">filled_values</span>
        <span class="n">new_mask_slice</span> <span class="o">=</span> <span class="o">~</span><span class="n">gap_mask</span> <span class="c1"># Initially, then update based on what was filled</span>
        <span class="n">new_mask_slice</span><span class="p">[</span><span class="n">gap_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Mark filled gaps as valid in the new mask</span>
        <span class="k">return</span> <span class="n">filled_slice</span><span class="p">,</span> <span class="n">new_mask_slice</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">):</span>
        <span class="n">new_3d_map</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_3d_mask</span> <span class="o">=</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="c1"># Iterate over altitude slices</span>
            <span class="n">filled_slice</span><span class="p">,</span> <span class="n">mask_slice</span> <span class="o">=</span> <span class="n">fill_2d_slice</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">new_3d_map</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">filled_slice</span>
            <span class="n">new_3d_mask</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_slice</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">new_3d_map</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">new_3d_mask</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">):</span> <span class="c1"># Has 2D altitude map as well</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="n">fill_2d_slice</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">new_mask</span> <span class="c1"># Update mask</span>
        <span class="c1"># Optionally fill altitude map if it also has gaps</span>
        <span class="c1"># map_obj.alt, _ = fill_2d_slice(map_obj.alt, map_obj.yy, map_obj.xx, k)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># MapS</span>
        <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">new_mask</span> <span class="o">=</span> <span class="n">fill_2d_slice</span><span class="p">(</span><span class="n">map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">new_mask</span> <span class="c1"># Update mask</span>
        
    <span class="k">return</span> <span class="n">map_obj</span></div>



<div class="viewcode-block" id="map_resample">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_resample">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_resample</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span>
                 <span class="n">new_yy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">new_xx</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">new_alt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># For MapS3D</span>
                 <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                 <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resamples a map object to a new grid (new_yy, new_xx, and optionally new_alt for MapS3D).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">map_obj</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">resampled_map_obj</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span> <span class="c1"># Shallow copy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resampled_map_obj</span> <span class="o">=</span> <span class="n">map_obj</span>
    
    <span class="n">itp</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Fill with 0 for areas outside original</span>
    <span class="k">if</span> <span class="n">itp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: Interpolator creation failed in map_resample. Returning original object.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">map_obj</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_alt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_alt must be provided for resampling MapS3D.&quot;</span><span class="p">)</span>
        <span class="n">yy_grid_new</span><span class="p">,</span> <span class="n">xx_grid_new</span><span class="p">,</span> <span class="n">alt_grid_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">new_yy</span><span class="p">,</span> <span class="n">new_xx</span><span class="p">,</span> <span class="n">new_alt</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">query_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">yy_grid_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">xx_grid_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">alt_grid_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">resampled_map_data</span> <span class="o">=</span> <span class="n">itp</span><span class="p">(</span><span class="n">query_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_yy</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_xx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_alt</span><span class="p">))</span>
        <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">new_alt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># MapS, MapSd</span>
        <span class="n">yy_grid_new</span><span class="p">,</span> <span class="n">xx_grid_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">new_yy</span><span class="p">,</span> <span class="n">new_xx</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">query_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">yy_grid_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">xx_grid_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
        <span class="n">resampled_map_data</span> <span class="o">=</span> <span class="n">itp</span><span class="p">(</span><span class="n">query_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_yy</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_xx</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Resample altitude map for MapSd</span>
            <span class="n">itp_alt</span> <span class="o">=</span> <span class="n">map_interpolate</span><span class="p">(</span><span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="nb">map</span><span class="o">=</span><span class="n">map_obj</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">itp_alt</span><span class="p">:</span>
                <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">itp_alt</span><span class="p">(</span><span class="n">query_points</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_yy</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_xx</span><span class="p">))</span>

    <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">resampled_map_data</span>
    <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">yy</span> <span class="o">=</span> <span class="n">new_yy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">xx</span> <span class="o">=</span> <span class="n">new_xx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># Create new meshgrid lat/lon if they existed</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">resampled_map_obj</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">new_yy</span><span class="p">,</span> <span class="n">new_xx</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="c1"># Create a new mask (True where resampled data is not the fill_value, assuming fill_value means gap)</span>
    <span class="c1"># This is a simple mask; a more sophisticated one might consider original mask</span>
    <span class="n">resampled_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">resampled_map_data</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> 
    
    <span class="k">return</span> <span class="n">resampled_map_obj</span></div>



<div class="viewcode-block" id="upward_fft">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.upward_fft">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">upward_fft</span><span class="p">(</span><span class="n">map_in</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapV</span><span class="p">],</span>
               <span class="n">alt_out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
               <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="c1"># Regularization for downward continuation</span>
               <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapV</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Placeholder for upward/downward continuation using FFT.</span>
<span class="sd">    This is a complex function requiring FFT, wavenumber grid creation, filtering, and iFFT.</span>
<span class="sd">    The actual implementation from MagNav.jl/src/map_fft.jl is non-trivial.</span>

<span class="sd">    Args:</span>
<span class="sd">        map_in: Input MapS, MapS3D, or MapV object.</span>
<span class="sd">        alt_out: Target altitude or array of altitudes [m].</span>
<span class="sd">        alpha: Regularization parameter for downward continuation (dz &lt; 0).</span>
<span class="sd">        expand: If true, expand map temporarily to reduce edge effects.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new map object of the same type as map_in, at alt_out.</span>
<span class="sd">        Currently returns a modified copy of map_in with updated altitude(s)</span>
<span class="sd">        and does NOT perform actual upward/downward continuation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO: Placeholder upward_fft called for map &#39;</span><span class="si">{</span><span class="n">map_in</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&#39; to target altitude(s) </span><span class="si">{</span><span class="n">alt_out</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      Full FFT-based upward/downward continuation is NOT YET IMPLEMENTED in this Python port.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      This function will return a copy of the input map with updated altitude(s) only.&quot;</span><span class="p">)</span>

    <span class="n">map_out</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_in</span><span class="p">)</span> <span class="c1"># Shallow copy for structure</span>
    
    <span class="c1"># Deep copy mutable fields</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;xx&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">xx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">xx</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;yy&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">yy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">yy</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;lat&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lat</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">map_out</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lon</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="p">,</span> <span class="n">MapV</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapX</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapX</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapX</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapY</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapY</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapY</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapZ</span> <span class="o">=</span> <span class="n">map_out</span><span class="o">.</span><span class="n">mapZ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">current_alt_scalar</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">current_alt_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">map_in</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">alt</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="n">current_alt_scalar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">map_in</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>

    <span class="n">dz</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">alt_out</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">alt_out</span><span class="p">)</span> <span class="o">-</span> <span class="n">current_alt_scalar</span>
    <span class="k">if</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      WARNING: Downward continuation (dz &lt; 0) attempted without regularization (alpha=0).&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;               This is unstable. Results will be unreliable.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="p">,</span> <span class="p">(</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapV</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_out</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">map_out</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">alt_out</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="p">,</span> <span class="n">MapS</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># Convert MapS to MapS3D</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      INFO: upward_fft converting MapS to MapS3D for multiple output altitudes.&quot;</span><span class="p">)</span>
        <span class="n">num_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_out</span><span class="p">)</span>
        <span class="n">original_map_data</span> <span class="o">=</span> <span class="n">map_in</span><span class="o">.</span><span class="n">map</span>
        <span class="n">new_3d_map_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">original_map_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="o">*</span> <span class="n">num_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_3d_mask_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_3d_mask_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">map_in</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="o">*</span> <span class="n">num_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">MapS3D</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">map_in</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">_to_3D&quot;</span><span class="p">,</span>
                      <span class="nb">map</span><span class="o">=</span><span class="n">new_3d_map_data</span><span class="p">,</span>
                      <span class="n">xx</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                      <span class="n">yy</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                      <span class="n">alt</span><span class="o">=</span><span class="n">alt_out</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                      <span class="n">mask</span><span class="o">=</span><span class="n">new_3d_mask_data</span><span class="p">,</span>
                      <span class="n">lat</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">lon</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Placeholder: For MapS3D output, we&#39;d need to actually compute each layer.</span>
        <span class="c1"># For now, just update the alt array and keep the first layer&#39;s data replicated.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      INFO: upward_fft for MapS3D with multiple altitudes will replicate first data layer.&quot;</span><span class="p">)</span>
        <span class="n">num_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alt_out</span><span class="p">)</span>
        <span class="n">first_layer_map</span> <span class="o">=</span> <span class="n">map_in</span><span class="o">.</span><span class="n">map</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">first_layer_mask</span> <span class="o">=</span> <span class="n">map_in</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        
        <span class="n">map_out</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">first_layer_map</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first_layer_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">first_layer_mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_levels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">map_out</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">alt_out</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_in</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt_out</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="c1"># Output a MapS from a MapS3D if single altitude is requested</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;      INFO: upward_fft converting MapS3D to MapS for single output altitude (using first layer data).&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MapS</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">map_in</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">_to_S&quot;</span><span class="p">,</span>
                    <span class="nb">map</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">map</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="c1"># Placeholder: use first layer</span>
                    <span class="n">xx</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">xx</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">yy</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">yy</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">alt</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">alt_out</span><span class="p">),</span>
                    <span class="n">mask</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">lat</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">lat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">lon</span><span class="o">=</span><span class="n">map_in</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">map_in</span><span class="o">.</span><span class="n">lon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">map_out</span><span class="o">.</span><span class="n">alt</span> <span class="o">=</span> <span class="n">alt_out</span> <span class="c1"># This might be an array for MapSd if alt_out is array</span>

    <span class="k">return</span> <span class="n">map_out</span></div>



<span class="c1"># Map Caching</span>
<div class="viewcode-block" id="map_cache_filename">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_cache_filename">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_cache_filename</span><span class="p">(</span><span class="n">map_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">alt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cache_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.map_cache&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a standard filename for a cached map.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Could not create cache directory </span><span class="si">{</span><span class="n">cache_dir</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Fallback to current directory if cache dir creation fails</span>
            <span class="n">cache_dir</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
            
    <span class="n">safe_map_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;_&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">map_name</span><span class="p">)</span>
    <span class="c1"># Ensure alt is a scalar for filename</span>
    <span class="n">alt_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">alt</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">alt</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">safe_map_name</span><span class="si">}</span><span class="s2">_alt</span><span class="si">{</span><span class="n">alt_scalar</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="save_map_to_cache">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.save_map_to_cache">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">save_map_to_cache</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapV</span><span class="p">],</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Saves a map object to a pickle file.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">map_obj</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="c1"># print(f&quot;Map &#39;{map_obj.info}&#39; saved to cache: {filename}&quot;)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error saving map to cache </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_map_from_cache">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.load_map_from_cache">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_map_from_cache</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapV</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Loads a map object from a pickle file.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">map_obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="c1"># print(f&quot;Map loaded from cache: {filename}&quot;)</span>
            <span class="k">return</span> <span class="n">map_obj</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading map from cache </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="get_cached_map">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.get_cached_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cached_map</span><span class="p">(</span><span class="n">map_cache_obj</span><span class="p">:</span> <span class="n">MapCache</span><span class="p">,</span> <span class="n">lat_query</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">lon_query</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alt_query</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets an interpolator from the map cache, prioritizing maps whose altitude is closest to alt_query</span>
<span class="sd">    and whose bounds contain (lat_query, lon_query).</span>
<span class="sd">    This is a simplified version of Julia&#39;s get_cached_map. Full version would involve</span>
<span class="sd">    on-the-fly upward_fft if a map at the exact dz interval isn&#39;t found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">best_interp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">min_alt_diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">found_suitable_map</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Check primary maps</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">map_info</span><span class="p">,</span> <span class="n">map_alt_scalar</span><span class="p">),</span> <span class="n">interp_func</span> <span class="ow">in</span> <span class="n">map_cache_obj</span><span class="o">.</span><span class="n">_interpolators</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Find the original map object to check bounds (this is a bit inefficient)</span>
        <span class="n">original_map</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">map_cache_obj</span><span class="o">.</span><span class="n">maps</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">info</span> <span class="o">==</span> <span class="n">map_info</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">m</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span> <span class="o">==</span> <span class="n">map_alt_scalar</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">original_map</span><span class="p">:</span>
            <span class="p">(</span><span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">),</span> <span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">)</span> <span class="o">=</span> <span class="n">map_lims</span><span class="p">(</span><span class="n">original_map</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">lat_min</span> <span class="o">&lt;=</span> <span class="n">lat_query</span> <span class="o">&lt;=</span> <span class="n">lat_max</span> <span class="ow">and</span> <span class="n">lon_min</span> <span class="o">&lt;=</span> <span class="n">lon_query</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">):</span>
                <span class="k">continue</span> <span class="c1"># Query point outside this map&#39;s bounds</span>

        <span class="n">alt_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">map_alt_scalar</span> <span class="o">-</span> <span class="n">alt_query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alt_diff</span> <span class="o">&lt;</span> <span class="n">min_alt_diff</span><span class="p">:</span>
            <span class="n">min_alt_diff</span> <span class="o">=</span> <span class="n">alt_diff</span>
            <span class="n">best_interp</span> <span class="o">=</span> <span class="n">interp_func</span>
            <span class="n">found_suitable_map</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">alt_diff</span> <span class="o">==</span> <span class="n">min_alt_diff</span><span class="p">:</span> <span class="c1"># Prefer maps closer to query altitude if multiple have same diff</span>
            <span class="c1"># This part could be more sophisticated, e.g. smaller map if multiple exact matches</span>
            <span class="k">pass</span>


    <span class="k">if</span> <span class="n">found_suitable_map</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">best_interp</span>
    
    <span class="c1"># Check fallback map if no primary map was suitable</span>
    <span class="k">if</span> <span class="n">map_cache_obj</span><span class="o">.</span><span class="n">_fallback_interpolator</span> <span class="ow">and</span> <span class="n">map_cache_obj</span><span class="o">.</span><span class="n">fallback_map</span><span class="p">:</span>
        <span class="p">(</span><span class="n">lat_min</span><span class="p">,</span> <span class="n">lat_max</span><span class="p">),</span> <span class="p">(</span><span class="n">lon_min</span><span class="p">,</span> <span class="n">lon_max</span><span class="p">)</span> <span class="o">=</span> <span class="n">map_lims</span><span class="p">(</span><span class="n">map_cache_obj</span><span class="o">.</span><span class="n">fallback_map</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lat_min</span> <span class="o">&lt;=</span> <span class="n">lat_query</span> <span class="o">&lt;=</span> <span class="n">lat_max</span> <span class="ow">and</span> <span class="n">lon_min</span> <span class="o">&lt;=</span> <span class="n">lon_query</span> <span class="o">&lt;=</span> <span class="n">lon_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">map_cache_obj</span><span class="o">.</span><span class="n">_fallback_interpolator</span>
            
    <span class="k">return</span> <span class="kc">None</span></div>



<span class="c1"># Placeholder/Simplified functions from Julia&#39;s map_functions.jl that are complex or have many dependencies</span>
<div class="viewcode-block" id="map_correct_igrf">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_correct_igrf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_correct_igrf</span><span class="p">(</span><span class="n">map_obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">],</span> <span class="n">sub_igrf_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">add_igrf_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapSd</span><span class="p">,</span> <span class="n">MapS3D</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Placeholder for IGRF correction. Requires a geomagnetic field model (e.g., IGRF).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: map_correct_igrf called for map </span><span class="si">{</span><span class="n">map_obj</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">. IGRF correction not implemented.&quot;</span><span class="p">)</span>
    <span class="c1"># In a real implementation, this would use a library like &#39;pyIGRF&#39; or &#39;geomagpy&#39;</span>
    <span class="c1"># to calculate IGRF values at each point (lat, lon, alt, date) and subtract/add them.</span>
    <span class="k">return</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span> <span class="c1"># Return a copy</span></div>


<div class="viewcode-block" id="map_combine">
<a class="viewcode-back" href="../../api_reference.html#magnavpy.map_utils.map_combine">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">map_combine</span><span class="p">(</span><span class="n">map1</span><span class="p">:</span> <span class="n">MapS</span><span class="p">,</span> <span class="n">map2</span><span class="p">:</span> <span class="n">MapS</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average_overlap&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MapS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplified combination of two MapS objects. Assumes they are at the same altitude.</span>
<span class="sd">    More complex combination (e.g., different altitudes, feathering) requires upward_fft and more logic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: map_combine called for maps </span><span class="si">{</span><span class="n">map1</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">map2</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">. Simple combination.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">map1</span><span class="o">.</span><span class="n">alt</span><span class="p">,</span> <span class="n">map2</span><span class="o">.</span><span class="n">alt</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: map_combine expects maps at same altitude for simple combination. Altitudes differ.&quot;</span><span class="p">)</span>
        <span class="c1"># Could attempt to continue one map to the other&#39;s altitude using upward_fft placeholder</span>
        <span class="c1"># map2 = upward_fft(map2, map1.alt)</span>

    <span class="c1"># For simplicity, this placeholder will assume maps need to be on the same grid.</span>
    <span class="c1"># A full implementation would resample one map to the other&#39;s grid or a common grid.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">map1</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="n">map2</span><span class="o">.</span><span class="n">xx</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">map1</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="n">map2</span><span class="o">.</span><span class="n">yy</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: map_combine placeholder requires maps to be on the same grid. Resampling not implemented here.&quot;</span><span class="p">)</span>
        <span class="c1"># Fallback: return map1 or raise error</span>
        <span class="k">return</span> <span class="n">map1</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">combined_map_obj</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">map1</span><span class="p">)</span>
        <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">map1</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">map1</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">combined_map_obj</span> <span class="o">=</span> <span class="n">map1</span>
    
    <span class="c1"># Example: prioritize map1, fill with map2 where map1 has no data (mask or NaN/0)</span>
    <span class="c1"># A more sophisticated method would average in overlap regions.</span>
    
    <span class="n">map1_gaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map1_gaps</span> <span class="o">=</span> <span class="n">map1_gaps</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

    <span class="n">map2_valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">map2</span><span class="o">.</span><span class="n">map</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">map2</span><span class="o">.</span><span class="n">map</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">map2_valid</span> <span class="o">=</span> <span class="n">map2_valid</span> <span class="o">&amp;</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span>

    <span class="n">fill_indices</span> <span class="o">=</span> <span class="n">map1_gaps</span> <span class="o">&amp;</span> <span class="n">map2_valid</span>
    <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">fill_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">map2</span><span class="o">.</span><span class="n">map</span><span class="p">[</span><span class="n">fill_indices</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">fill_indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Or map2.mask[fill_indices]</span>
    <span class="k">elif</span> <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># Start with map2&#39;s mask</span>
         <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">~</span><span class="n">fill_indices</span> <span class="o">&amp;</span> <span class="n">map1_gaps</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Ensure map1 gaps stay masked if not filled</span>
    <span class="k">elif</span> <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">map2</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">combined_map_obj</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>


    <span class="n">combined_map_obj</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Combined: </span><span class="si">{</span><span class="n">map1</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2"> &amp; </span><span class="si">{</span><span class="n">map2</span><span class="o">.</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">combined_map_obj</span></div>



<span class="c1"># Functions from the original map_utils.py that are being kept or slightly adapted</span>
<div class="viewcode-block" id="get_map">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.get_map">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_map</span><span class="p">(</span><span class="n">map_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">variable_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;map_data&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">map_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MapS</span><span class="p">,</span> <span class="n">MapV</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_MAP_UTILS_GET_MAP: ID of this get_map: </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">get_map</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># New print</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;IMMEDIATE_GET_MAP_ENTRY: map_name=&#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39;, var_name=&#39;</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2">&#39;, args=</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">, map_type_param=&#39;</span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="s2">&#39;, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG_GET_MAP_ENTRY: map_name=&#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39;, variable_name=&#39;</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2">&#39;, map_type=&#39;</span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="s2">&#39;, args=</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">, kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves a specific magnetic map, attempting to load from a .mat file if map_name is a path.</span>
<span class="sd">    If map_name is a known ID (e.g., &quot;namad&quot;, &quot;emm720&quot;), it returns a placeholder.</span>
<span class="sd">    This function is a placeholder and primarily for loading test .mat files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">map_name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.mat&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mat_content</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">map_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">variable_name</span> <span class="ow">in</span> <span class="n">mat_content</span><span class="p">:</span>
                <span class="n">data_struct</span> <span class="o">=</span> <span class="n">mat_content</span><span class="p">[</span><span class="n">variable_name</span><span class="p">]</span>
                
                <span class="c1"># Common structure for .mat files from MagNav test data:</span>
                <span class="c1"># data_struct is often a struct array, so access fields via [0,0] and then field name.</span>
                <span class="c1"># Field names might be &#39;map&#39;, &#39;xx&#39;, &#39;yy&#39;, &#39;alt&#39;, &#39;info&#39;, &#39;mask&#39;</span>
                <span class="c1"># Or nested like data_struct[&#39;map&#39;][0,0]</span>
                
                <span class="n">map_values</span> <span class="o">=</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;map&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">map_xx_deg</span> <span class="o">=</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;xx&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;xx&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">map_yy_deg</span> <span class="o">=</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;yy&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;yy&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">map_alt_m</span> <span class="o">=</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;alt&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;alt&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">map_info_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">and</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;Loaded from </span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">map_mask_bool</span> <span class="o">=</span> <span class="n">data_struct</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="n">data_struct</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">map_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">map_values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_xx_deg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_yy_deg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">map_alt_m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Essential map fields (map, xx, yy, alt) not found in </span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2"> under variable </span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2">. Returning MAP_S_NULL.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">MAP_S_NULL</span>

                <span class="c1"># Convert degrees to radians for xx, yy as per common convention in MagNav</span>
                <span class="n">map_xx_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">map_xx_deg</span><span class="p">)</span>
                <span class="n">map_yy_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">map_yy_deg</span><span class="p">)</span>
                
                <span class="c1"># Ensure alt is scalar if it&#39;s supposed to be (e.g. for MapS)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_alt_m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_alt_m</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">map_alt_m_scalar</span> <span class="o">=</span> <span class="n">map_alt_m</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_alt_m</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                    <span class="n">map_alt_m_scalar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">map_alt_m</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># If alt is an array (e.g. for MapSd or if map is 3D)</span>
                    <span class="c1"># This loader is simplified for MapS, so we might take the mean or first value</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Altitude from .mat file is an array. Taking mean for MapS.alt: </span><span class="si">{</span><span class="n">map_alt_m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">map_alt_m_scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">map_alt_m</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_alt_m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">map_alt_m</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>


                <span class="c1"># Create lat, lon meshgrids if needed by MapS type (though interpolator uses xx, yy vectors)</span>
                <span class="c1"># yy_mesh, xx_mesh = np.meshgrid(map_yy_rad, map_xx_rad, indexing=&#39;ij&#39;)</span>

                <span class="k">return</span> <span class="n">MapS</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">map_info_str</span><span class="p">,</span>
                            <span class="nb">map</span><span class="o">=</span><span class="n">map_values</span><span class="p">,</span>
                            <span class="n">xx</span><span class="o">=</span><span class="n">map_xx_rad</span><span class="p">,</span>
                            <span class="n">yy</span><span class="o">=</span><span class="n">map_yy_rad</span><span class="p">,</span>
                            <span class="n">alt</span><span class="o">=</span><span class="n">map_alt_m_scalar</span><span class="p">,</span>
                            <span class="n">mask</span><span class="o">=</span><span class="n">map_mask_bool</span><span class="p">,</span>
                            <span class="n">lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="c1"># Placeholder, not directly from typical .mat</span>
                            <span class="n">lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># Placeholder</span>
                            <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: Variable &#39;</span><span class="si">{</span><span class="n">variable_name</span><span class="si">}</span><span class="s2">&#39; not found in </span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">. Returning MAP_S_NULL.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">MAP_S_NULL</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading map from </span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning MAP_S_NULL.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">MAP_S_NULL</span>
    
    <span class="c1"># Fallback for known map IDs or if file not found/not .mat</span>
    <span class="k">if</span> <span class="n">map_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;namad&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: get_map called for NAMAD. Returning MAP_S_NULL. Load actual NAMAD data separately.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">map_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;emm720&quot;</span> <span class="ow">or</span> <span class="s2">&quot;emm720&quot;</span> <span class="ow">in</span> <span class="n">map_name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;debug_get_map.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_debug</span><span class="p">:</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- New get_map emm720 entry ---</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;EMM720_BLOCK_ENTERED: map_name=&#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;KWARGS: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Using direct map_type parameter now for f_debug</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FDEBUG_MAP_TYPE_PARAM_VAL: </span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FDEBUG_TYPE_MAP_TYPE_PARAM: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">map_type</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">is_vector_robust_check_fdebug</span> <span class="o">=</span> <span class="n">map_type</span> <span class="ow">and</span> <span class="n">map_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;vector&#39;</span>
            <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;FDEBUG_IS_VECTOR_ROBUST_CHECK_RESULT: </span><span class="si">{</span><span class="n">is_vector_robust_check_fdebug</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: In get_map emm720 block. map_name=&#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: kwargs received: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Using direct map_type parameter now for print</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: map_type parameter value: </span><span class="si">{</span><span class="n">map_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: type of map_type parameter: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">map_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;DEBUG: Condition (map_type and map_type.lower() == &#39;vector&#39;) is: </span><span class="si">{</span><span class="n">map_type</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">map_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s1">&#39;vector&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">map_type</span> <span class="ow">and</span> <span class="n">map_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;vector&quot;</span><span class="p">:</span> <span class="c1"># Use the direct parameter, robustly</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;debug_get_map.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_debug</span><span class="p">:</span>
                <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;EMM720_BLOCK_VECTOR_PATH_TAKEN</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: get_map called for EMM720 (or similar) with map_type=&#39;vector&#39;. Returning DUMMY MapV. Load actual EMM720 data separately.&quot;</span><span class="p">)</span>
            <span class="c1"># Create a minimal valid MapV object to prevent ValueError in create_flux</span>
            <span class="c1"># Ensure xx and yy are 1D and have at least one element.</span>
            <span class="c1"># Ensure x, y, z components match dimensions of xx, yy.</span>
            <span class="n">dummy_xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="c1"># Min 2 points for some interpolators if not careful</span>
            <span class="n">dummy_yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
            <span class="n">dummy_data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">dummy_yy</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dummy_xx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">MapV</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="s2">&quot;Dummy EMM720 Vector Map&quot;</span><span class="p">,</span>
                        <span class="n">alt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                        <span class="n">mapX</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dummy_data_shape</span><span class="p">),</span>
                        <span class="n">mapY</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dummy_data_shape</span><span class="p">),</span>
                        <span class="n">mapZ</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dummy_data_shape</span><span class="p">),</span>
                        <span class="n">xx</span><span class="o">=</span><span class="n">dummy_xx</span><span class="p">,</span>
                        <span class="n">yy</span><span class="o">=</span><span class="n">dummy_yy</span><span class="p">,</span>
                        <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dummy_data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
                        <span class="n">lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="c1"># Placeholder</span>
                        <span class="n">lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="c1"># Placeholder</span>
                        <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Corresponds to: if kwargs.get(&#39;map_type&#39;) == &quot;vector&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;debug_get_map.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f_debug</span><span class="p">:</span>
                <span class="n">f_debug</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;EMM720_BLOCK_SCALAR_PATH_TAKEN</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: get_map called for EMM720 (scalar, or similar). Returning MAP_S_NULL. Load actual EMM720 data separately.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">MAP_S_NULL</span> <span class="c1"># Original behavior for scalar</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Corresponds to: if map_name.lower() == &quot;namad&quot;: / elif map_name.lower() == &quot;emm720&quot;:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: get_map called for &#39;</span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">&#39;. File not found or not a .mat, or unknown ID. Returning MAP_S_NULL.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MAP_S_NULL</span></div>


<span class="c1"># Placeholders for specific map loaders mentioned in original map_utils or task</span>
<div class="viewcode-block" id="ottawa_area_maps">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.ottawa_area_maps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ottawa_area_maps</span><span class="p">(</span><span class="n">map_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapS</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Placeholder: ottawa_area_maps called for </span><span class="si">{</span><span class="n">map_name</span><span class="si">}</span><span class="s2">. Not implemented.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MAP_S_NULL</span></div>


<div class="viewcode-block" id="namad">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.namad">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">namad</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapS</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Placeholder: namad map loader called. Not implemented. Use get_map with path to NAMAD data.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MAP_S_NULL</span></div>


<div class="viewcode-block" id="emag2">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.emag2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">emag2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapS</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Placeholder: emag2 map loader called. Not implemented.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MAP_S_NULL</span></div>


<div class="viewcode-block" id="emm720">
<a class="viewcode-back" href="../../maps.html#magnavpy.map_utils.emm720">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">emm720</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MapS</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Placeholder: emm720 map loader called. Not implemented. Use get_map with path to EMM720 data.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MAP_S_NULL</span></div>


<span class="c1"># --- End of map_utils.py content ---</span>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2020-2023, Original MagNav.jl Authors; 2024-2025, Manas Pandey.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>